  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 0.3148500919342041
-----> check2 time: 1.9073486328125e-6
-----> Jacobian time: 0.1333768367767334
-----> LP OPT1 time: 7.152557373046875e-6
-----> LP OPT2 time: 4.887580871582031e-5
-----> LP OPT3 time: 3.814697265625e-6
-----> LP OPT4 time: 0.16407108306884766
-----> LP OPT5 time: 5.1021575927734375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-2.0]
mult_x_L = [3.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.5, 0.5]
qp.v_ub = [Inf, Inf]
x_k = [0.5, 0.5]
qp.c_lb = [-Inf]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  2.0
  [1, 2]  =  1.0
qp.b = [1.0]
c = [-1.0, -2.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 2.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 5.15991997718811
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 1.1920928955078125e-6
-----> check5 time: 0.0
-----> check6 time: 7.867813110351562e-6
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 6.198883056640625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 0.12274599075317383
-----> check8 time: 0.12277507781982422
-----> check9 time: 2.86102294921875e-6
     1  -1.50000000e+00  -1.50000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.50000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 1.0967254638671875e-5
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 2.86102294921875e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 2.86102294921875e-6
-----> LP OPT4 time: 2.6941299438476562e-5
-----> LP OPT5 time: 2.193450927734375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.3333333333333333]
mult_x_L = [1.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.5, 0.5]
qp.v_ub = [Inf, Inf]
x_k = [0.5, 0.5]
qp.c_lb = [-Inf]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.5
  [1, 2]  =  1.5
qp.b = [0.75]
c = [-1.0, -2.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.5, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.5, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.25)]
-> check2
---> check3
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.5 1.5 1.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.25]
-----> check2_1 time: 0.0007779598236083984
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 1.9073486328125e-6
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 9.5367431640625e-7
-----> KT_residuals3 time: 1.0967254638671875e-5
-----> check8 time: 1.7881393432617188e-5
-----> check9 time: 0.0
     1  -1.50000000e+00  -1.50000000e+00  -3.33333333e-01  -3.33333333e-01  1.66666667e-01  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.25000000e-01  4.00000000e+00
-----> check10 time: 0.0025968551635742188
-----> check start
-----> check1 time: 6.9141387939453125e-6
-----> check2 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> LP OPT1 time: 2.1457672119140625e-6
-----> LP OPT2 time: 1.0967254638671875e-5
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.4080276489257812e-5
-----> LP OPT5 time: 1.7881393432617188e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.1111111111111112]
mult_x_L = [0.8333333333333335, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.5, 0.5]
qp.v_ub = [Inf, Inf]
x_k = [0.5, 0.65]
qp.c_lb = [-Inf]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.65
  [1, 2]  =  1.8
qp.b = [0.9975]
c = [-1.0, -2.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-0.15000000000000002), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.8, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.6500000000000001, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0024999999999999467)]
-> check2
---> check3
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.6500000000000001 1.8 1.0 -1.0]
b = [1000.0, 1000.0, 0.0, -0.15000000000000002, 0.0, 0.0, 0.0024999999999999467]
-----> check2_1 time: 0.0008280277252197266
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 2.1457672119140625e-6
-----> check7 time: 0.0
-----> Jacobian time: 3.0994415283203125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.5020370483398438e-5
-----> check8 time: 2.3126602172851562e-5
-----> check9 time: 0.0
     2  -1.80000000e+00  -1.80000000e+00  -2.77777778e-03  -2.77777778e-03  1.38888889e-03  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.16279070e-03  4.00000000e+00
-----> check10 time: 4.100799560546875e-5
-----> check start
-----> check1 time: 5.0067901611328125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 1.0013580322265625e-5
-----> LP OPT3 time: 2.86102294921875e-6
-----> LP OPT4 time: 1.4781951904296875e-5
-----> LP OPT5 time: 1.3828277587890625e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.1093990755007703]
mult_x_L = [0.8320493066255776, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.5, 0.5]
qp.v_ub = [Inf, Inf]
x_k = [0.5, 0.6513888888888889]
qp.c_lb = [-Inf]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.65139
  [1, 2]  =  1.80278
qp.b = [1.0000019290123459]
c = [-1.0, -2.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-0.1513888888888889), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.8027777777777778, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.6513888888888888, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(-1.929012345858183e-6)]
-> check2
---> check3
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.6513888888888888 1.8027777777777778 1.0 -1.0]
b = [1000.0, 1000.0, 0.0, -0.1513888888888889, 0.0, 0.0, -1.929012345858183e-6]
-----> check2_1 time: 0.0006129741668701172
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 2.1457672119140625e-6
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 3.0994415283203125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.0013580322265625e-5
-----> check8 time: 1.71661376953125e-5
-----> check9 time: 9.5367431640625e-7
     3  -1.80277778e+00  -1.80275849e+00  -1.71500789e-05  +2.14004451e-06  1.07002226e-06  1.00000000e+01  1.00000000e+03  0.00000000e+00  1.92901235e-06  3.34859338e-17  8.96635822e-07  4.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 1.0967254638671875e-5
-----> check2 time: 1.1920928955078125e-6
-----> Jacobian time: 5.0067901611328125e-6
-----> LP OPT1 time: 2.86102294921875e-6
-----> LP OPT2 time: 4.0531158447265625e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 3.314018249511719e-5
-----> LP OPT5 time: 3.504753112792969e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0, 1000.0]
mult_x_L = [2000.0, 1000.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, 1.0]
qp.c_ub = [2.0, Inf]
qp.A = 
  [1, 1]  =  -2.0
  [2, 1]  =  -2.0
  [1, 2]  =  -1.0
  [2, 2]  =  -1.0
qp.b = [0.0, 0.0]
solve_farkas_interval_lower: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 4-element Array{Float64,1} at index [5]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize! at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Bridges/bridge_optimizer.jl:264 [inlined]
   [8] solve_farkas_interval_lower(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/UnitTests/solve.jl:313
   [9] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [10] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [11] unittest(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [12] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:62
   [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [14] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:29
   [15] include(::String) at ./client.jl:457
   [16] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [17] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [18] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [19] include(::Function, ::Module, ::String) at ./Base.jl:380
   [20] include(::Module, ::String) at ./Base.jl:368
   [21] exec_options(::Base.JLOptions) at ./client.jl:296
   [22] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 9.059906005859375e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 4.0531158447265625e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 4.0531158447265625e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.384185791015625e-5
-----> LP OPT5 time: 2.002716064453125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.5]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [0.0]
qp.c_lb = [-Inf]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  2.0
qp.b = [0.0]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1.0)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.0 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, 1.0]
-----> check2_1 time: 0.0008089542388916016
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 9.5367431640625e-7
-----> check6 time: 2.1457672119140625e-6
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 1.9073486328125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.0013580322265625e-5
-----> check8 time: 1.7881393432617188e-5
-----> check9 time: 0.0
     1  -0.00000000e+00  +0.00000000e+00  -5.00000000e-01  -5.00000000e-01  5.00000000e-01  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  3.33333333e-01  2.00000000e+00
-----> check10 time: 3.886222839355469e-5
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 8.106231689453125e-6
-----> LP OPT3 time: 2.1457672119140625e-6
-----> LP OPT4 time: 1.0013580322265625e-5
-----> LP OPT5 time: 1.0967254638671875e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.5]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [0.5]
qp.c_lb = [-Inf]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  2.0
qp.b = [1.0]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.0 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0005259513854980469
-----> check3 time: 0.0
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.1920928955078125e-5
-----> check9 time: 0.0
     2  -5.00000000e-01  -5.00000000e-01  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  2.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 8.106231689453125e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 2.1457672119140625e-6
-----> LP OPT1 time: 2.1457672119140625e-6
-----> LP OPT2 time: 3.814697265625e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 3.0994415283203125e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [0.0]
mult_x_U = [-1.0]
qp.v_lb = [-Inf]
qp.v_ub = [0.0]
x_k = [0.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [-1.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 2
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0)]
-> check1
---> check2
A = [1.0; 1.0]
b = [0.0, -1000.0]
-----> check2_1 time: 0.007951974868774414
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 2.1457672119140625e-6
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.4066696166992188e-5
-----> check8 time: 2.09808349609375e-5
-----> check9 time: 9.5367431640625e-7
     1  -0.00000000e+00  +0.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 9.059906005859375e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 1.9073486328125e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [3.0]
mult_x_U = [0.0]
qp.v_lb = [1.0]
qp.v_ub = [Inf]
x_k = [1.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [3.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 2
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
A = [1.0; 1.0]
b = [1000.0, 0.0]
-----> check2_1 time: 0.0007200241088867188
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 1.9073486328125e-6
-----> check7 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.5974044799804688e-5
-----> check8 time: 2.193450927734375e-5
-----> check9 time: 9.5367431640625e-7
     1  +3.00000000e+00  +3.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 6.9141387939453125e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 2.1457672119140625e-6
-----> LP OPT2 time: 4.0531158447265625e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 2.1457672119140625e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [1.0]
mult_x_U = [0.0]
qp.v_lb = [0.0]
qp.v_ub = [Inf]
x_k = [0.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [1.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 2
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
A = [1.0; 1.0]
b = [1000.0, 0.0]
-----> check2_1 time: 0.0006058216094970703
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 2.1457672119140625e-6
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.3828277587890625e-5
-----> check8 time: 1.9073486328125e-5
-----> check9 time: 0.0
     1  +0.00000000e+00  +0.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 8.106231689453125e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 4.0531158447265625e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 2.86102294921875e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.09808349609375e-5
-----> LP OPT5 time: 1.9073486328125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1000.0]
mult_x_L = [2000.0, 1000.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf]
qp.c_ub = [-1.0]
qp.A = 
  [1, 1]  =  2.0
  [1, 2]  =  1.0
qp.b = [0.0]
solve_farkas_lessthan: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 2-element Array{Float64,1} at index [3]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize! at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Bridges/bridge_optimizer.jl:264 [inlined]
   [8] solve_farkas_lessthan(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/UnitTests/solve.jl:238
   [9] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [10] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [11] unittest(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [12] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:62
   [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [14] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:29
   [15] include(::String) at ./client.jl:457
   [16] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [17] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [18] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [19] include(::Function, ::Module, ::String) at ./Base.jl:380
   [20] include(::Module, ::String) at ./Base.jl:368
   [21] exec_options(::Base.JLOptions) at ./client.jl:296
   [22] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 5.9604644775390625e-6
-----> check2 time: 1.1920928955078125e-6
-----> Jacobian time: 3.0994415283203125e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 5.0067901611328125e-6
-----> LP OPT3 time: 2.86102294921875e-6
-----> LP OPT4 time: 2.4080276489257812e-5
-----> LP OPT5 time: 1.811981201171875e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1000.0, 0.0]
mult_x_L = [2000.0, 1000.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, -2.0]
qp.c_ub = [-1.0, Inf]
qp.A = 
  [1, 1]  =  2.0
  [2, 1]  =  2.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [0.0, 0.0]
solve_farkas_interval_upper: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 4-element Array{Float64,1} at index [5]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize! at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Bridges/bridge_optimizer.jl:264 [inlined]
   [8] solve_farkas_interval_upper(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/UnitTests/solve.jl:288
   [9] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [10] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [11] unittest(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [12] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:62
   [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [14] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:29
   [15] include(::String) at ./client.jl:457
   [16] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [17] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [18] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [19] include(::Function, ::Module, ::String) at ./Base.jl:380
   [20] include(::Module, ::String) at ./Base.jl:368
   [21] exec_options(::Base.JLOptions) at ./client.jl:296
   [22] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 1.0013580322265625e-5
-----> check2 time: 0.0
-----> Jacobian time: 2.86102294921875e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 5.0067901611328125e-6
-----> LP OPT3 time: 4.0531158447265625e-6
-----> LP OPT4 time: 2.4080276489257812e-5
-----> LP OPT5 time: 2.09808349609375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [1000.0]
mult_x_L = [2000.0, 1000.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [1.0]
qp.c_ub = [Inf]
qp.A = 
  [1, 1]  =  -2.0
  [1, 2]  =  -1.0
qp.b = [0.0]
solve_farkas_greaterthan: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 2-element Array{Float64,1} at index [3]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize! at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Bridges/bridge_optimizer.jl:264 [inlined]
   [8] solve_farkas_greaterthan(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/UnitTests/solve.jl:263
   [9] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [10] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [11] unittest(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [12] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:62
   [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [14] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:29
   [15] include(::String) at ./client.jl:457
   [16] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [17] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [18] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [19] include(::Function, ::Module, ::String) at ./Base.jl:380
   [20] include(::Module, ::String) at ./Base.jl:368
   [21] exec_options(::Base.JLOptions) at ./client.jl:296
   [22] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 7.867813110351562e-6
-----> check2 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> LP OPT1 time: 2.1457672119140625e-6
-----> LP OPT2 time: 4.76837158203125e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 2.1457672119140625e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [1.0]
mult_x_U = [0.0]
qp.v_lb = [1.0]
qp.v_ub = [Inf]
x_k = [1.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [1.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 2
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
A = [1.0; 1.0]
b = [1000.0, 0.0]
-----> check2_1 time: 0.0007200241088867188
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 1.9073486328125e-6
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.4066696166992188e-5
-----> check8 time: 2.002716064453125e-5
-----> check9 time: 0.0
     1  +1.00000000e+00  +1.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 0.0
-----> Jacobian time: 0.0
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 2.1457672119140625e-6
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 2.1457672119140625e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [1.0]
mult_x_U = [0.0]
qp.v_lb = [1.0]
qp.v_ub = [Inf]
x_k = [1.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [1.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 2
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
A = [1.0; 1.0]
b = [1000.0, 0.0]
-----> check2_1 time: 0.00037598609924316406
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.0967254638671875e-5
-----> check9 time: 0.0
     1  +1.00000000e+00  +1.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 7.867813110351562e-6
-----> check2 time: 0.0
-----> Jacobian time: 2.86102294921875e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 1.9073486328125e-6
-----> LP OPT3 time: 2.86102294921875e-6
-----> LP OPT4 time: 2.1219253540039062e-5
-----> LP OPT5 time: 1.5974044799804688e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [1000.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [-2001.0, -1000.0]
qp.v_lb = [-Inf, -Inf]
qp.v_ub = [0.0, 0.0]
x_k = [0.0, 0.0]
qp.c_lb = [1.0]
qp.c_ub = [Inf]
qp.A = 
  [1, 1]  =  2.0
  [1, 2]  =  1.0
qp.b = [0.0]
solve_farkas_variable_lessthan_max: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 3-element Array{Float64,1} at index [4]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize! at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Bridges/bridge_optimizer.jl:264 [inlined]
   [8] solve_farkas_variable_lessthan_max(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/UnitTests/solve.jl:369
   [9] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [10] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [11] unittest(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [12] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:62
   [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [14] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:29
   [15] include(::String) at ./client.jl:457
   [16] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [17] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [18] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [19] include(::Function, ::Module, ::String) at ./Base.jl:380
   [20] include(::Module, ::String) at ./Base.jl:368
   [21] exec_options(::Base.JLOptions) at ./client.jl:296
   [22] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 6.9141387939453125e-6
-----> check2 time: 0.0
-----> Jacobian time: 4.0531158447265625e-6
-----> LP OPT1 time: 1.1920928955078125e-6
-----> LP OPT2 time: 7.867813110351562e-6
-----> LP OPT3 time: 2.86102294921875e-6
-----> LP OPT4 time: 2.5033950805664062e-5
-----> LP OPT5 time: 1.9073486328125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.5]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [0.0]
qp.c_lb = [-Inf]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  2.0
qp.b = [0.0]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1.0)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.0 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, 1.0]
-----> check2_1 time: 0.0008440017700195312
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 0.0
-----> Jacobian time: 3.0994415283203125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.0967254638671875e-5
-----> check8 time: 1.71661376953125e-5
-----> check9 time: 9.5367431640625e-7
     1  -0.00000000e+00  +0.00000000e+00  -5.00000000e-01  -5.00000000e-01  5.00000000e-01  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  3.33333333e-01  2.00000000e+00
-----> check10 time: 3.814697265625e-5
-----> check start
-----> check1 time: 4.0531158447265625e-6
-----> check2 time: 0.0
-----> Jacobian time: 1.1920928955078125e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 9.059906005859375e-6
-----> LP OPT3 time: 2.1457672119140625e-6
-----> LP OPT4 time: 1.1920928955078125e-5
-----> LP OPT5 time: 1.2159347534179688e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.5]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [0.5]
qp.c_lb = [-Inf]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  2.0
qp.b = [1.0]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.0 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0005471706390380859
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 1.1920928955078125e-6
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.3113021850585938e-5
-----> check9 time: 9.5367431640625e-7
     2  -5.00000000e-01  -5.00000000e-01  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  2.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 7.867813110351562e-6
-----> check2 time: 0.0
-----> Jacobian time: 3.0994415283203125e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 2.86102294921875e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.4080276489257812e-5
-----> LP OPT5 time: 1.9073486328125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [1000.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [-2000.0, -1000.0]
qp.v_lb = [-Inf, -Inf]
qp.v_ub = [0.0, 0.0]
x_k = [0.0, 0.0]
qp.c_lb = [1.0]
qp.c_ub = [Inf]
qp.A = 
  [1, 1]  =  2.0
  [1, 2]  =  1.0
qp.b = [0.0]
solve_farkas_variable_lessthan: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 2-element Array{Float64,1} at index [3]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize! at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Bridges/bridge_optimizer.jl:264 [inlined]
   [8] solve_farkas_variable_lessthan(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/UnitTests/solve.jl:338
   [9] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [10] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [11] unittest(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [12] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:62
   [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [14] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:29
   [15] include(::String) at ./client.jl:457
   [16] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [17] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [18] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [19] include(::Function, ::Module, ::String) at ./Base.jl:380
   [20] include(::Module, ::String) at ./Base.jl:368
   [21] exec_options(::Base.JLOptions) at ./client.jl:296
   [22] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 1.0013580322265625e-5
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 4.0531158447265625e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 5.0067901611328125e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.5033950805664062e-5
-----> LP OPT5 time: 2.2172927856445312e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1000.0]
mult_x_L = [2000.0, 1000.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-1.0]
qp.c_ub = [-1.0]
qp.A = 
  [1, 1]  =  2.0
  [1, 2]  =  1.0
qp.b = [0.0]
solve_farkas_equalto_upper: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 2-element Array{Float64,1} at index [3]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize! at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Bridges/bridge_optimizer.jl:264 [inlined]
   [8] solve_farkas_equalto_upper(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/UnitTests/solve.jl:188
   [9] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [10] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [11] unittest(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [12] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:62
   [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [14] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:29
   [15] include(::String) at ./client.jl:457
   [16] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [17] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [18] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [19] include(::Function, ::Module, ::String) at ./Base.jl:380
   [20] include(::Module, ::String) at ./Base.jl:368
   [21] exec_options(::Base.JLOptions) at ./client.jl:296
   [22] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 6.198883056640625e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 2.1457672119140625e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 2.1457672119140625e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [2.0, 4.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [1.0, 2.0]
qp.v_ub = [Inf, Inf]
x_k = [1.0, 2.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [2.0, 4.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 4
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
A = [1.0 0.0; 0.0 1.0; 1.0 0.0; 0.0 1.0]
b = [1000.0, 1000.0, 0.0, 0.0]
-----> check2_1 time: 0.0005829334259033203
-----> check3 time: 0.0
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 2.1457672119140625e-6
-----> check7 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.5020370483398438e-5
-----> check8 time: 2.002716064453125e-5
-----> check9 time: 9.5367431640625e-7
     1  +5.00000000e+00  +5.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 4.0531158447265625e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 2.1457672119140625e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 1.1920928955078125e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [4.0, 4.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [1.0, 2.0]
qp.v_ub = [Inf, Inf]
x_k = [1.0, 2.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [4.0, 4.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 4
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
A = [1.0 0.0; 0.0 1.0; 1.0 0.0; 0.0 1.0]
b = [1000.0, 1000.0, 0.0, 0.0]
-----> check2_1 time: 0.0004401206970214844
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 8.821487426757812e-6
-----> check8 time: 1.4066696166992188e-5
-----> check9 time: 0.0
     1  +7.00000000e+00  +7.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 0.0
-----> LP OPT2 time: 9.5367431640625e-7
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 9.5367431640625e-7
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [4.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [1.0, 2.0]
qp.v_ub = [Inf, Inf]
x_k = [1.0, 2.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [4.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 4
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
Duplicate diagonal terms: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/UnitTests/objectives.jl:224
  Got exception outside of a @test
  BoundsError: attempt to access 4×1 Array{Float64,2} at index [2, 2]
  Stacktrace:
   [1] setindex! at ./array.jl:849 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:287
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize! at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Bridges/bridge_optimizer.jl:264 [inlined]
   [8] test_model_solution(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}; objective_value::Float64, variable_primal::Array{Tuple{MathOptInterface.VariableIndex,Float64},1}, constraint_primal::Nothing, constraint_dual::Nothing) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/UnitTests/unit_tests.jl:61
   [9] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/UnitTests/objectives.jl:234 [inlined]
   [10] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [11] solve_qp_edge_cases(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/UnitTests/objectives.jl:226
   [12] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [13] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [14] unittest(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [15] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:62
   [16] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [17] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:29
   [18] include(::String) at ./client.jl:457
   [19] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [20] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [21] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [22] include(::Function, ::Module, ::String) at ./Base.jl:380
   [23] include(::Module, ::String) at ./Base.jl:368
   [24] exec_options(::Base.JLOptions) at ./client.jl:296
   [25] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 8.106231689453125e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 1.1920928955078125e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 2.1457672119140625e-6
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 1.9073486328125e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [4.0, 5.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [1.0, 2.0]
qp.v_ub = [Inf, Inf]
x_k = [1.0, 2.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [4.0, 5.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 4
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
A = [1.0 0.0; 0.0 1.0; 1.0 0.0; 0.0 1.0]
b = [1000.0, 1000.0, 0.0, 0.0]
-----> check2_1 time: 0.0006091594696044922
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 2.1457672119140625e-6
-----> check7 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 1.1920928955078125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.3113021850585938e-5
-----> check8 time: 1.9073486328125e-5
-----> check9 time: 0.0
     1  +7.00000000e+00  +7.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 1.0013580322265625e-5
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 2.86102294921875e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 2.86102294921875e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.6941299438476562e-5
-----> LP OPT5 time: 2.288818359375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [1000.0]
mult_x_L = [2000.0, 1000.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  -2.0
  [1, 2]  =  -1.0
qp.b = [0.0]
solve_farkas_equalto_lower: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 2-element Array{Float64,1} at index [3]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize! at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Bridges/bridge_optimizer.jl:264 [inlined]
   [8] solve_farkas_equalto_lower(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/UnitTests/solve.jl:213
   [9] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [10] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [11] unittest(::MathOptInterface.Bridges.LazyBridgeOptimizer{ActiveSetMethods.Optimizer}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [12] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:62
   [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [14] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:29
   [15] include(::String) at ./client.jl:457
   [16] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [17] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [18] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [19] include(::Function, ::Module, ::String) at ./Base.jl:380
   [20] include(::Module, ::String) at ./Base.jl:368
   [21] exec_options(::Base.JLOptions) at ./client.jl:296
   [22] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 8.106231689453125e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 4.0531158447265625e-6
-----> LP OPT1 time: 2.1457672119140625e-6
-----> LP OPT2 time: 5.0067901611328125e-6
-----> LP OPT3 time: 4.0531158447265625e-6
-----> LP OPT4 time: 2.193450927734375e-5
-----> LP OPT5 time: 2.2172927856445312e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0]
mult_x_L = [2.0, 0.0, 0.0]
mult_x_U = [0.0, 0.0, -2.0]
qp.v_lb = [0.0, 0.0, 0.0]
qp.v_ub = [Inf, Inf, 1.0]
x_k = [0.0, 0.0, 0.0]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 
  [1, 1]  =  3.0
  [1, 2]  =  2.0
  [1, 3]  =  1.0
qp.b = [0.0]
c = [-1.0, -2.0, -3.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 9
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1.0)]
-> check1
---> check1
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(3.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(2.0)]
-> check2
---> check3
A = [1.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 1.0; 3.0 2.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.0]
-----> check2_1 time: 0.001043081283569336
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 1.9073486328125e-6
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 1.9073486328125e-6
-----> KT_residuals2 time: 9.5367431640625e-7
-----> KT_residuals3 time: 1.2159347534179688e-5
-----> check8 time: 1.9073486328125e-5
-----> check9 time: 9.5367431640625e-7
     1  -4.00000000e+00  -4.00000000e+00  -4.00000000e+00  -4.00000000e+00  1.11803399e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  5.00000000e-01  1.00000000e+00
-----> check10 time: 3.719329833984375e-5
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 8.821487426757812e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.3113021850585938e-5
-----> LP OPT5 time: 1.2874603271484375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0]
mult_x_L = [2.0, 0.0, 0.0]
mult_x_U = [0.0, 0.0, -2.0]
qp.v_lb = [0.0, 0.0, 0.0]
qp.v_ub = [Inf, Inf, 1.0]
x_k = [0.0, 0.5, 1.0]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 
  [1, 1]  =  3.0
  [1, 2]  =  2.0
  [1, 3]  =  1.0
qp.b = [2.0]
c = [-1.0, -2.0, -3.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 9
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(0.0)]
-> check1
---> check1
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-0.5), MathOptInterface.GreaterThan{Float64}(-1.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(3.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
A = [1.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 1.0; 3.0 2.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, -0.5, -1.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0006060600280761719
-----> check3 time: 0.0
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.867813110351562e-6
-----> check8 time: 1.2874603271484375e-5
-----> check9 time: 1.1920928955078125e-6
     2  -8.00000000e+00  -8.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 8.821487426757812e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 4.0531158447265625e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 2.86102294921875e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.4080276489257812e-5
-----> LP OPT5 time: 2.09808349609375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [0.0]
qp.v_ub = [Inf]
x_k = [0.0]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 
  [1, 1]  =  2.0
qp.b = [0.0]
c = [-2.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(2.0)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.0 1.0 -1.0]
b = [1000.0, 0.0, 0.0, 0.0, 2.0]
-----> check2_1 time: 0.0009388923645019531
-----> check3 time: 1.1920928955078125e-6
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 1.9073486328125e-6
-----> check7 time: 1.1920928955078125e-6
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 1.1920928955078125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.0967254638671875e-5
-----> check8 time: 1.7881393432617188e-5
-----> check9 time: 0.0
     1  -4.00000000e+00  -4.00000000e+00  -2.00000000e+00  -2.00000000e+00  1.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00  1.00000000e+00
-----> check10 time: 3.600120544433594e-5
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 1.1920928955078125e-6
-----> LP OPT2 time: 6.9141387939453125e-6
-----> LP OPT3 time: 2.1457672119140625e-6
-----> LP OPT4 time: 1.1920928955078125e-5
-----> LP OPT5 time: 1.0967254638671875e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [0.0]
qp.v_ub = [Inf]
x_k = [1.0]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 
  [1, 1]  =  2.0
qp.b = [2.0]
c = [-2.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.0 1.0 -1.0]
b = [1000.0, -1.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0005729198455810547
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.152557373046875e-6
-----> check8 time: 1.3113021850585938e-5
-----> check9 time: 0.0
     2  -6.00000000e+00  -6.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 7.152557373046875e-6
-----> check2 time: 0.0
-----> Jacobian time: 3.0994415283203125e-6
-----> LP OPT1 time: 1.1920928955078125e-6
-----> LP OPT2 time: 2.86102294921875e-6
-----> LP OPT3 time: 4.0531158447265625e-6
-----> LP OPT4 time: 2.6226043701171875e-5
-----> LP OPT5 time: 2.193450927734375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0, 1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [-Inf, -Inf]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, 0.0]
qp.c_ub = [0.0, Inf]
qp.A = 
  [2, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [0.0, 0.0]
c = [1.0, -1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 0.0 1.0 1.0 0.0 -1.0 0.0; 1.0 0.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, -1000.0, -1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.2928800582885742
-----> check3 time: 1.1920928955078125e-6
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 4.0531158447265625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 2.288818359375e-5
-----> check8 time: 3.409385681152344e-5
-----> check9 time: 0.0
     1  +0.00000000e+00  +0.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  5.00000000e-01
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 8.106231689453125e-6
-----> check2 time: 0.0
-----> Jacobian time: 3.0994415283203125e-6
-----> LP OPT1 time: 2.1457672119140625e-6
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 3.814697265625e-6
-----> LP OPT4 time: 2.7894973754882812e-5
-----> LP OPT5 time: 2.3126602172851562e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0, 1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [-Inf, -Inf]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, 100.0]
qp.c_ub = [0.0, Inf]
qp.A = 
  [2, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [0.0, 0.0]
c = [1.0, -1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(100.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 0.0 1.0 1.0 0.0 -1.0 0.0; 1.0 0.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, -1000.0, -1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 100.0]
-----> check2_1 time: 0.0011019706726074219
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 1.9073486328125e-6
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.2159347534179688e-5
-----> check8 time: 2.002716064453125e-5
-----> check9 time: 9.5367431640625e-7
     1  +0.00000000e+00  +1.00000000e+03  -9.00000000e+02  +1.00000000e+02  1.00000000e+02  1.00000000e+01  1.00000000e+03  0.00000000e+00  1.00000000e+02  0.00000000e+00  4.14213562e+01  5.00000000e-01
-----> check10 time: 3.910064697265625e-5
-----> check start
-----> check1 time: 4.0531158447265625e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 9.059906005859375e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 1.7881393432617188e-5
-----> LP OPT5 time: 1.4066696166992188e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0, 1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [-Inf, -Inf]
qp.v_ub = [Inf, Inf]
x_k = [100.0, 0.0]
qp.c_lb = [-Inf, 100.0]
qp.c_ub = [0.0, Inf]
qp.A = 
  [2, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [0.0, 100.0]
c = [1.0, -1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 0.0 1.0 1.0 0.0 -1.0 0.0; 1.0 0.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, -1000.0, -1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0009930133819580078
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 1.1920928955078125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 8.106231689453125e-6
-----> check8 time: 1.5020370483398438e-5
-----> check9 time: 0.0
     2  +1.00000000e+02  +1.00000000e+02  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  5.00000000e-01
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 3.814697265625e-6
-----> check2 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> LP OPT1 time: 1.1920928955078125e-6
-----> LP OPT2 time: 2.86102294921875e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 1.6927719116210938e-5
-----> LP OPT5 time: 1.6927719116210938e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0, 1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [-Inf, -Inf]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, 100.0]
qp.c_ub = [-100.0, Inf]
qp.A = 
  [2, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [0.0, 0.0]
c = [1.0, -1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(-100.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(100.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 0.0 1.0 1.0 0.0 -1.0 0.0; 1.0 0.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, -1000.0, -1000.0, 0.0, 0.0, 0.0, 0.0, -100.0, 100.0]
-----> check2_1 time: 0.0007388591766357422
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.2874603271484375e-5
-----> check9 time: 9.5367431640625e-7
     1  +0.00000000e+00  +2.00000000e+03  -1.80000000e+03  +2.00000000e+02  1.41421356e+02  1.00000000e+01  1.00000000e+03  0.00000000e+00  1.00000000e+02  0.00000000e+00  4.14213562e+01  5.00000000e-01
-----> check10 time: 2.4080276489257812e-5
-----> check start
-----> check1 time: 2.1457672119140625e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 6.9141387939453125e-6
-----> LP OPT3 time: 2.1457672119140625e-6
-----> LP OPT4 time: 1.5020370483398438e-5
-----> LP OPT5 time: 1.5020370483398438e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0, 1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [-Inf, -Inf]
qp.v_ub = [Inf, Inf]
x_k = [100.0, -100.0]
qp.c_lb = [-Inf, 100.0]
qp.c_ub = [-100.0, Inf]
qp.A = 
  [2, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [-100.0, 100.0]
c = [1.0, -1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 0.0 1.0 1.0 0.0 -1.0 0.0; 1.0 0.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, -1000.0, -1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0007169246673583984
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 1.1920928955078125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.2874603271484375e-5
-----> check9 time: 0.0
     2  +2.00000000e+02  +2.00000000e+02  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  5.00000000e-01
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 7.867813110351562e-6
-----> check2 time: 1.1920928955078125e-6
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 8.106231689453125e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 1.9073486328125e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [1.0, 0.0]
mult_x_U = [0.0, -1.0]
qp.v_lb = [0.0, -Inf]
qp.v_ub = [Inf, 0.0]
x_k = [0.0, 0.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [1.0, -1.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 4
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(0.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-1000.0)]
-> check1
---> check2
-> check1
---> check2
A = [1.0 0.0; 0.0 1.0; 1.0 0.0; 0.0 1.0]
b = [1000.0, 0.0, 0.0, -1000.0]
-----> check2_1 time: 0.0007579326629638672
-----> check3 time: 1.1920928955078125e-6
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 1.9073486328125e-6
-----> check7 time: 1.1920928955078125e-6
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.3828277587890625e-5
-----> check8 time: 1.9788742065429688e-5
-----> check9 time: 1.1920928955078125e-6
     1  +0.00000000e+00  +0.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 2.1457672119140625e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 1.9073486328125e-6
-----> LP OPT3 time: 1.1920928955078125e-6
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 1.9073486328125e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [1.0, 0.0]
mult_x_U = [0.0, -1.0]
qp.v_lb = [100.0, -Inf]
qp.v_ub = [Inf, 0.0]
x_k = [100.0, 0.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [1.0, -1.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 4
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(0.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-1000.0)]
-> check1
---> check2
-> check1
---> check2
A = [1.0 0.0; 0.0 1.0; 1.0 0.0; 0.0 1.0]
b = [1000.0, 0.0, 0.0, -1000.0]
-----> check2_1 time: 0.0004849433898925781
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 1.1920928955078125e-6
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 9.5367431640625e-7
-----> KT_residuals3 time: 8.106231689453125e-6
-----> check8 time: 1.1920928955078125e-5
-----> check9 time: 0.0
     1  +1.00000000e+02  +1.00000000e+02  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 0.0
-----> Jacobian time: 0.0
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 1.9073486328125e-6
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 1.9073486328125e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [1.0, 0.0]
mult_x_U = [0.0, -1.0]
qp.v_lb = [100.0, -Inf]
qp.v_ub = [Inf, -100.0]
x_k = [100.0, -100.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [1.0, -1.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 4
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(0.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-1000.0)]
-> check1
---> check2
-> check1
---> check2
A = [1.0 0.0; 0.0 1.0; 1.0 0.0; 0.0 1.0]
b = [1000.0, 0.0, 0.0, -1000.0]
-----> check2_1 time: 0.000453948974609375
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 0.0
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.152557373046875e-6
-----> check8 time: 1.1205673217773438e-5
-----> check9 time: 0.0
     1  +2.00000000e+02  +2.00000000e+02  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 7.867813110351562e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 2.86102294921875e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.193450927734375e-5
-----> LP OPT5 time: 1.9073486328125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [1.0]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [0.0]
qp.v_ub = [Inf]
x_k = [0.0]
qp.c_lb = [3.0]
qp.c_ub = [Inf]
qp.A = 
  [1, 1]  =  1.0
qp.b = [0.0]
c = [1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(3.0)]
-> check2
---> check4
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 1.0 1.0 -1.0]
b = [1000.0, 0.0, 0.0, 0.0, 3.0]
-----> check2_1 time: 0.0009458065032958984
-----> check3 time: 0.0
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.0013580322265625e-5
-----> check8 time: 1.6927719116210938e-5
-----> check9 time: 1.1920928955078125e-6
     1  +0.00000000e+00  +3.00000000e+01  -2.70000000e+01  +3.00000000e+00  3.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  3.00000000e+00  0.00000000e+00  1.50000000e+00  1.00000000e+00
-----> check10 time: 3.600120544433594e-5
-----> check start
-----> check1 time: 2.1457672119140625e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 0.0
-----> LP OPT2 time: 1.0013580322265625e-5
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 1.0967254638671875e-5
-----> LP OPT5 time: 1.1920928955078125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [1.0]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [0.0]
qp.v_ub = [Inf]
x_k = [3.0]
qp.c_lb = [3.0]
qp.c_ub = [Inf]
qp.A = 
  [1, 1]  =  1.0
qp.b = [3.0]
c = [1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-3.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0)]
-> check2
---> check4
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 1.0 1.0 -1.0]
b = [1000.0, -3.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.00067901611328125
-----> check3 time: 0.0
-----> check4 time: 1.1920928955078125e-6
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 1.1920928955078125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.2874603271484375e-5
-----> check9 time: 0.0
     2  +3.00000000e+00  +3.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 1.9073486328125e-6
-----> LP OPT3 time: 2.1457672119140625e-6
-----> LP OPT4 time: 1.1920928955078125e-5
-----> LP OPT5 time: 1.0967254638671875e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0]
mult_x_L = [0.0]
mult_x_U = [-1.0]
qp.v_lb = [-Inf]
qp.v_ub = [0.0]
x_k = [0.0]
qp.c_lb = [-Inf]
qp.c_ub = [3.0]
qp.A = 
  [1, 1]  =  1.0
qp.b = [0.0]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(3.0)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 1.0 1.0 -1.0]
b = [0.0, -1000.0, 0.0, 0.0, 3.0]
-----> check2_1 time: 0.0005910396575927734
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.867813110351562e-6
-----> check8 time: 1.2874603271484375e-5
-----> check9 time: 0.0
     1  -0.00000000e+00  +0.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 8.106231689453125e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 3.0994415283203125e-6
-----> LP OPT1 time: 2.1457672119140625e-6
-----> LP OPT2 time: 4.0531158447265625e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 3.504753112792969e-5
-----> LP OPT5 time: 2.6941299438476562e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-11.363636363636369, -0.8636363636363635, 0.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [30.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [30.0, 0.0]
qp.c_lb = [-Inf, -Inf, 0.0]
qp.c_ub = [1000.0, 70000.0, Inf]
qp.A = 
  [1, 1]  =  12.0
  [2, 1]  =  1000.0
  [3, 1]  =  1.0
  [1, 2]  =  8.0
  [2, 2]  =  300.0
  [3, 2]  =  -1.5
qp.b = [360.0, 30000.0, 30.0]
c = [-1000.0, -350.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 13
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(7), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(8)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(7)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(8))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(8.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(12.0, MathOptInterface.VariableIndex(1))], 0.0), MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(7)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(300.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1000.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(640.0), MathOptInterface.LessThan{Float64}(40000.0)]
-> check2
---> check3
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(8)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(-1.5, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-30.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0; 12.0 8.0 1.0 0.0 0.0 -1.0 0.0 0.0; 1000.0 300.0 0.0 1.0 0.0 0.0 -1.0 0.0; 1.0 -1.5 0.0 0.0 1.0 0.0 0.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 640.0, 40000.0, -30.0]
-----> check2_1 time: 0.0011091232299804688
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 0.0
-----> Jacobian time: 3.0994415283203125e-6
-----> KT_residuals1 time: 1.9073486328125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.0967254638671875e-5
-----> check8 time: 1.811981201171875e-5
-----> check9 time: 0.0
     1  -3.00000000e+04  -3.00000000e+04  -4.18181818e+04  -4.18181818e+04  4.65681763e+01  1.13637364e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  2.78673117e+03  1.00000000e+00
-----> check10 time: 3.504753112792969e-5
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 1.71661376953125e-5
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.09808349609375e-5
-----> LP OPT5 time: 1.9073486328125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-11.363636363636369, -0.8636363636363635, 0.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [30.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [59.09090909090909, 36.363636363636346]
qp.c_lb = [-Inf, -Inf, 0.0]
qp.c_ub = [1000.0, 70000.0, Inf]
qp.A = 
  [1, 1]  =  12.0
  [2, 1]  =  1000.0
  [3, 1]  =  1.0
  [1, 2]  =  8.0
  [2, 2]  =  300.0
  [3, 2]  =  -1.5
qp.b = [999.9999999999999, 70000.0, 4.545454545454575]
c = [-1000.0, -350.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 13
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(7), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(8)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(7)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(8))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-29.090909090909093), MathOptInterface.GreaterThan{Float64}(-36.363636363636346), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(8.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(12.0, MathOptInterface.VariableIndex(1))], 0.0), MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(7)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(300.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1000.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0), MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(8)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(-1.5, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-4.545454545454575)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0; 12.0 8.0 1.0 0.0 0.0 -1.0 0.0 0.0; 1000.0 300.0 0.0 1.0 0.0 0.0 -1.0 0.0; 1.0 -1.5 0.0 0.0 1.0 0.0 0.0 -1.0]
b = [1000.0, 1000.0, -29.090909090909093, -36.363636363636346, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -4.545454545454575]
-----> check2_1 time: 0.0008499622344970703
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.867813110351562e-6
-----> check8 time: 1.3113021850585938e-5
-----> check9 time: 9.5367431640625e-7
     2  -7.18181818e+04  -7.18181818e+04  -3.19744231e-12  -3.19744231e-12  2.38323279e-14  1.13637364e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.04215347e-13  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 7.867813110351562e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 4.0531158447265625e-6
-----> LP OPT1 time: 2.1457672119140625e-6
-----> LP OPT2 time: 4.0531158447265625e-6
-----> LP OPT3 time: 4.0531158447265625e-6
-----> LP OPT4 time: 2.5987625122070312e-5
-----> LP OPT5 time: 2.288818359375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0]
mult_x_L = [0.0, 1.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [0.0]
linear1: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 3-element Array{Float64,1} at index [4]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize!(::MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.Model{Float64}}}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Utilities/cachingoptimizer.jl:215
   [8] optimize! at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Bridges/bridge_optimizer.jl:264 [inlined]
   [9] linear1test(::MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64,F,S,LS,US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction,MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.Model{Float64}}}}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/contlinear.jl:72
   [10] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [11] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [12] contlineartest(::MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64,F,S,LS,US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction,MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.Model{Float64}}}}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [13] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:76
   [14] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [15] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:66
   [16] include(::String) at ./client.jl:457
   [17] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [18] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [19] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [20] include(::Function, ::Module, ::String) at ./Base.jl:380
   [21] include(::Module, ::String) at ./Base.jl:368
   [22] exec_options(::Base.JLOptions) at ./client.jl:296
   [23] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 9.059906005859375e-6
-----> check2 time: 0.0
-----> Jacobian time: 4.0531158447265625e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.288818359375e-5
-----> LP OPT5 time: 2.09808349609375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0]
mult_x_L = [0.0, 1.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [0.0]
linear2: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 3-element Array{Float64,1} at index [4]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize!(::MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.Model{Float64}}}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Utilities/cachingoptimizer.jl:215
   [8] optimize! at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Bridges/bridge_optimizer.jl:264 [inlined]
   [9] linear2test(::MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64,F,S,LS,US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction,MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.Model{Float64}}}}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/contlinear.jl:424
   [10] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [11] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [12] contlineartest(::MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64,F,S,LS,US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction,MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.Model{Float64}}}}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [13] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:76
   [14] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [15] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:66
   [16] include(::String) at ./client.jl:457
   [17] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [18] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [19] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [20] include(::Function, ::Module, ::String) at ./Base.jl:380
   [21] include(::Module, ::String) at ./Base.jl:368
   [22] exec_options(::Base.JLOptions) at ./client.jl:296
   [23] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 1.0013580322265625e-5
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 2.86102294921875e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 5.0067901611328125e-6
-----> LP OPT3 time: 2.86102294921875e-6
-----> LP OPT4 time: 2.4080276489257812e-5
-----> LP OPT5 time: 5.507469177246094e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-2.0]
mult_x_L = [0.0, 1.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [1.0, 0.0]
qp.c_lb = [-Inf]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [1.0]
c = [-2.0, -1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, -1.0, 0.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0010800361633300781
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 2.1457672119140625e-6
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 1.9073486328125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.2159347534179688e-5
-----> check8 time: 2.002716064453125e-5
-----> check9 time: 0.0
     1  -2.00000000e+00  -2.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 9.775161743164062e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 3.0994415283203125e-6
-----> LP OPT1 time: 1.1920928955078125e-6
-----> LP OPT2 time: 4.0531158447265625e-6
-----> LP OPT3 time: 4.0531158447265625e-6
-----> LP OPT4 time: 2.6941299438476562e-5
-----> LP OPT5 time: 2.193450927734375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0, 0.0]
mult_x_L = [1.0, 1.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, -1.0]
qp.c_ub = [10.0, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [0.0, 0.0]
c = [1.0, 1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(10.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 0.0 -1.0 0.0; 1.0 1.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10.0, -1.0]
-----> check2_1 time: 0.0010859966278076172
-----> check3 time: 1.1920928955078125e-6
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 1.9073486328125e-6
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.0013580322265625e-5
-----> check8 time: 1.7881393432617188e-5
-----> check9 time: 9.5367431640625e-7
     1  +0.00000000e+00  +0.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 9.059906005859375e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 4.0531158447265625e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 8.106231689453125e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.8848648071289062e-5
-----> LP OPT5 time: 1.9788742065429688e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0, 0.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, 5.0]
qp.c_ub = [10.0, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [0.0, 0.0]
c = [-1.0, -1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(10.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(5.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 0.0 -1.0 0.0; 1.0 1.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10.0, 5.0]
-----> check2_1 time: 0.0010581016540527344
-----> check3 time: 0.0
-----> check4 time: 2.1457672119140625e-6
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 2.86102294921875e-6
-----> KT_residuals1 time: 1.1920928955078125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.0967254638671875e-5
-----> check8 time: 1.9073486328125e-5
-----> check9 time: 0.0
     1  -0.00000000e+00  +5.00000000e+01  -6.00000000e+01  -1.00000000e+01  1.00000000e+01  1.00000000e+01  1.00000000e+03  0.00000000e+00  5.00000000e+00  0.00000000e+00  5.00000000e+00  1.00000000e+00
-----> check10 time: 3.504753112792969e-5
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 0.0
-----> Jacobian time: 1.1920928955078125e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 8.106231689453125e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 1.6927719116210938e-5
-----> LP OPT5 time: 1.3113021850585938e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0, 0.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 10.0]
qp.c_lb = [-Inf, 5.0]
qp.c_ub = [10.0, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [10.0, 10.0]
c = [-1.0, -1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-10.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-5.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 0.0 -1.0 0.0; 1.0 1.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, 0.0, -10.0, 0.0, 0.0, 0.0, 0.0, 0.0, -5.0]
-----> check2_1 time: 0.0007531642913818359
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.2874603271484375e-5
-----> check9 time: 1.1920928955078125e-6
     2  -1.00000000e+01  -1.00000000e+01  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 2.1457672119140625e-6
-----> LP OPT4 time: 1.6927719116210938e-5
-----> LP OPT5 time: 1.5974044799804688e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0, 1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, 5.0]
qp.c_ub = [10.0, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [0.0, 0.0]
c = [1.0, 1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(10.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(5.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 0.0 -1.0 0.0; 1.0 1.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10.0, 5.0]
-----> check2_1 time: 0.0008099079132080078
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 8.106231689453125e-6
-----> check8 time: 1.5020370483398438e-5
-----> check9 time: 0.0
     1  +0.00000000e+00  +5.00000000e+01  -4.50000000e+01  +5.00000000e+00  5.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  5.00000000e+00  0.00000000e+00  2.50000000e+00  1.00000000e+00
-----> check10 time: 2.384185791015625e-5
-----> check start
-----> check1 time: 4.0531158447265625e-6
-----> check2 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 1.0967254638671875e-5
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.71661376953125e-5
-----> LP OPT5 time: 2.5987625122070312e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0, 1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 5.0]
qp.c_lb = [-Inf, 5.0]
qp.c_ub = [10.0, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [5.0, 5.0]
c = [1.0, 1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-5.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(5.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 0.0 -1.0 0.0; 1.0 1.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, 0.0, -5.0, 0.0, 0.0, 0.0, 0.0, 5.0, 0.0]
-----> check2_1 time: 0.0009541511535644531
-----> check3 time: 1.1920928955078125e-6
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 1.1920928955078125e-6
-----> Jacobian time: 2.86102294921875e-6
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.1920928955078125e-5
-----> check8 time: 1.8835067749023438e-5
-----> check9 time: 0.0
     2  +5.00000000e+00  +5.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 9.059906005859375e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 4.0531158447265625e-6
-----> LP OPT1 time: 2.1457672119140625e-6
-----> LP OPT2 time: 4.0531158447265625e-6
-----> LP OPT3 time: 2.86102294921875e-6
-----> LP OPT4 time: 2.7894973754882812e-5
-----> LP OPT5 time: 2.5033950805664062e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0, 1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, 2.0]
qp.c_ub = [12.0, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [0.0, 0.0]
c = [1.0, 1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(12.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(2.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 0.0 -1.0 0.0; 1.0 1.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 12.0, 2.0]
-----> check2_1 time: 0.0011470317840576172
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 1.9073486328125e-6
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 3.0994415283203125e-6
-----> KT_residuals1 time: 1.9073486328125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.0013580322265625e-5
-----> check8 time: 1.7881393432617188e-5
-----> check9 time: 0.0
     1  +0.00000000e+00  +2.00000000e+01  -1.80000000e+01  +2.00000000e+00  2.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  2.00000000e+00  0.00000000e+00  1.00000000e+00  1.00000000e+00
-----> check10 time: 3.886222839355469e-5
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 9.059906005859375e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.71661376953125e-5
-----> LP OPT5 time: 1.4066696166992188e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0, 1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 2.0]
qp.c_lb = [-Inf, 2.0]
qp.c_ub = [12.0, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [2.0, 2.0]
c = [1.0, 1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-2.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(10.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 0.0 -1.0 0.0; 1.0 1.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0, 10.0, 0.0]
-----> check2_1 time: 0.0007898807525634766
-----> check3 time: 0.0
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 8.106231689453125e-6
-----> check8 time: 1.4066696166992188e-5
-----> check9 time: 0.0
     2  +2.00000000e+00  +2.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 2.1457672119140625e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.6927719116210938e-5
-----> LP OPT5 time: 1.5974044799804688e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0, 0.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, 2.0]
qp.c_ub = [12.0, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [0.0, 0.0]
c = [-1.0, -1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(12.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(2.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 0.0 -1.0 0.0; 1.0 1.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 12.0, 2.0]
-----> check2_1 time: 0.0008790493011474609
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 9.059906005859375e-6
-----> check8 time: 1.5974044799804688e-5
-----> check9 time: 9.5367431640625e-7
     1  -0.00000000e+00  +2.00000000e+01  -3.20000000e+01  -1.20000000e+01  1.20000000e+01  1.00000000e+01  1.00000000e+03  0.00000000e+00  2.00000000e+00  0.00000000e+00  6.00000000e+00  1.00000000e+00
-----> check10 time: 2.288818359375e-5
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 8.821487426757812e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.5974044799804688e-5
-----> LP OPT5 time: 1.3828277587890625e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0, 0.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 12.0]
qp.c_lb = [-Inf, 2.0]
qp.c_ub = [12.0, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [12.0, 12.0]
c = [-1.0, -1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-12.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-10.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 0.0 -1.0 0.0; 1.0 1.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, 0.0, -12.0, 0.0, 0.0, 0.0, 0.0, 0.0, -10.0]
-----> check2_1 time: 0.0007889270782470703
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.152557373046875e-6
-----> check8 time: 1.5974044799804688e-5
-----> check9 time: 1.1920928955078125e-6
     2  -1.20000000e+01  -1.20000000e+01  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 9.059906005859375e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 4.0531158447265625e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 4.0531158447265625e-6
-----> LP OPT3 time: 8.106231689453125e-6
-----> LP OPT4 time: 2.7894973754882812e-5
-----> LP OPT5 time: 2.5033950805664062e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.33333333333333337, -0.3333333333333333]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, -Inf]
qp.c_ub = [4.0, 4.0]
qp.A = 
  [1, 1]  =  2.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  2.0
qp.b = [0.0, 0.0]
c = [-1.0, -1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 0.0), MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(4.0), MathOptInterface.LessThan{Float64}(4.0)]
-> check2
---> check3
-> check2
---> check3
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 2.0 1.0 1.0 0.0 -1.0 0.0; 1.0 2.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 4.0, 4.0]
-----> check2_1 time: 0.0011229515075683594
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 2.1457672119140625e-6
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.0013580322265625e-5
-----> check8 time: 2.002716064453125e-5
-----> check9 time: 0.0
     1  -0.00000000e+00  +0.00000000e+00  -2.66666667e+00  -2.66666667e+00  1.88561808e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  9.06163679e-01  1.00000000e+00
-----> check10 time: 3.409385681152344e-5
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 8.106231689453125e-6
-----> LP OPT3 time: 2.1457672119140625e-6
-----> LP OPT4 time: 1.6927719116210938e-5
-----> LP OPT5 time: 1.6927719116210938e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.33333333333333337, -0.3333333333333333]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [1.3333333333333333, 1.3333333333333335]
qp.c_lb = [-Inf, -Inf]
qp.c_ub = [4.0, 4.0]
qp.A = 
  [1, 1]  =  2.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  2.0
qp.b = [4.0, 4.0]
c = [-1.0, -1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1.3333333333333333), MathOptInterface.GreaterThan{Float64}(-1.3333333333333335), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 0.0), MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0), MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
-> check2
---> check3
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 2.0 1.0 1.0 0.0 -1.0 0.0; 1.0 2.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, -1.3333333333333333, -1.3333333333333335, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0007719993591308594
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.152557373046875e-6
-----> check8 time: 1.3113021850585938e-5
-----> check9 time: 1.1920928955078125e-6
     2  -2.66666667e+00  -2.66666667e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 9.059906005859375e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 3.0994415283203125e-6
-----> LP OPT1 time: 2.1457672119140625e-6
-----> LP OPT2 time: 4.0531158447265625e-6
-----> LP OPT3 time: 3.814697265625e-6
-----> LP OPT4 time: 2.7894973754882812e-5
-----> LP OPT5 time: 2.3126602172851562e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.5, 0.0]
mult_x_L = [0.0, 0.5]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, -Inf]
qp.c_ub = [4.0, 4.0]
qp.A = 
  [1, 1]  =  2.0
  [2, 1]  =  1.0
  [1, 2]  =  3.0
  [2, 2]  =  2.0
qp.b = [0.0, 0.0]
c = [-1.0, -1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(3.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 0.0), MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(4.0), MathOptInterface.LessThan{Float64}(4.0)]
-> check2
---> check3
-> check2
---> check3
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 2.0 3.0 1.0 0.0 -1.0 0.0; 1.0 2.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 4.0, 4.0]
-----> check2_1 time: 0.0009260177612304688
-----> check3 time: 0.0
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 1.9073486328125e-6
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 1.1920928955078125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 8.821487426757812e-6
-----> check8 time: 1.5974044799804688e-5
-----> check9 time: 0.0
     1  -0.00000000e+00  +0.00000000e+00  -2.00000000e+00  -2.00000000e+00  2.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.17157288e+00  1.00000000e+00
-----> check10 time: 3.2901763916015625e-5
-----> check start
-----> check1 time: 4.0531158447265625e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 1.1920928955078125e-6
-----> LP OPT1 time: 0.0
-----> LP OPT2 time: 7.152557373046875e-6
-----> LP OPT3 time: 2.1457672119140625e-6
-----> LP OPT4 time: 1.5974044799804688e-5
-----> LP OPT5 time: 1.4066696166992188e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.5, 0.0]
mult_x_L = [0.0, 0.5]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [2.0, 0.0]
qp.c_lb = [-Inf, -Inf]
qp.c_ub = [4.0, 4.0]
qp.A = 
  [1, 1]  =  2.0
  [2, 1]  =  1.0
  [1, 2]  =  3.0
  [2, 2]  =  2.0
qp.b = [4.0, 2.0]
c = [-1.0, -1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-2.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(3.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 0.0), MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0), MathOptInterface.LessThan{Float64}(2.0)]
-> check2
---> check3
-> check2
---> check3
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 2.0 3.0 1.0 0.0 -1.0 0.0; 1.0 2.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, -2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.0]
-----> check2_1 time: 0.0007240772247314453
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.867813110351562e-6
-----> check8 time: 1.5974044799804688e-5
-----> check9 time: 0.0
     2  -2.00000000e+00  -2.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.4066696166992188e-5
-----> LP OPT5 time: 1.2874603271484375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0]
mult_x_L = [0.0, 1.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf]
qp.c_ub = [4.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  2.0
qp.b = [0.0]
c = [-1.0, -1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(4.0)]
-> check2
---> check3
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 2.0 1.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, 0.0, 0.0, 4.0]
-----> check2_1 time: 0.0007109642028808594
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 9.5367431640625e-7
-----> KT_residuals3 time: 7.152557373046875e-6
-----> check8 time: 1.5020370483398438e-5
-----> check9 time: 0.0
     1  -0.00000000e+00  +0.00000000e+00  -4.00000000e+00  -4.00000000e+00  4.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.65685425e+00  1.00000000e+00
-----> check10 time: 2.2172927856445312e-5
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 6.9141387939453125e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.0967254638671875e-5
-----> LP OPT5 time: 1.2159347534179688e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0]
mult_x_L = [0.0, 1.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [4.0, 0.0]
qp.c_lb = [-Inf]
qp.c_ub = [4.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  2.0
qp.b = [4.0]
c = [-1.0, -1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-4.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 2.0 1.0 -1.0]
b = [1000.0, 1000.0, -4.0, 0.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.000640869140625
-----> check3 time: 0.0
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.4066696166992188e-5
-----> check9 time: 0.0
     2  -4.00000000e+00  -4.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 4.0531158447265625e-6
-----> check2 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> LP OPT1 time: 0.0
-----> LP OPT2 time: 2.1457672119140625e-6
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 1.2159347534179688e-5
-----> LP OPT5 time: 1.2874603271484375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.5]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [0.0]
qp.v_ub = [Inf]
x_k = [0.0]
qp.c_lb = [-Inf]
qp.c_ub = [4.0]
qp.A = 
  [1, 1]  =  2.0
qp.b = [0.0]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(4.0)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.0 1.0 -1.0]
b = [1000.0, 0.0, 0.0, 0.0, 4.0]
-----> check2_1 time: 0.0006921291351318359
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.152557373046875e-6
-----> check8 time: 1.3113021850585938e-5
-----> check9 time: 0.0
     1  -0.00000000e+00  +0.00000000e+00  -2.00000000e+00  -2.00000000e+00  2.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.33333333e+00  1.00000000e+00
-----> check10 time: 2.2172927856445312e-5
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 9.059906005859375e-6
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 1.0967254638671875e-5
-----> LP OPT5 time: 1.0013580322265625e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.5]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [0.0]
qp.v_ub = [Inf]
x_k = [2.0]
qp.c_lb = [-Inf]
qp.c_ub = [4.0]
qp.A = 
  [1, 1]  =  2.0
qp.b = [4.0]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-2.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.0)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.0 1.0 -1.0]
b = [1000.0, -2.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0006089210510253906
-----> check3 time: 1.1920928955078125e-6
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.152557373046875e-6
-----> check8 time: 1.1205673217773438e-5
-----> check9 time: 0.0
     2  -2.00000000e+00  -2.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 8.821487426757812e-6
-----> check2 time: 0.0
-----> Jacobian time: 2.86102294921875e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 6.198883056640625e-6
-----> LP OPT3 time: 2.86102294921875e-6
-----> LP OPT4 time: 3.3855438232421875e-5
-----> LP OPT5 time: 1.71661376953125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0, 0.0, 0.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [-Inf, -Inf]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, 1.0, 0.0]
qp.c_ub = [0.0, Inf, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  2.0
  [3, 1]  =  1.0
  [1, 2]  =  -1.0
  [2, 2]  =  3.0
  [3, 2]  =  -1.0
qp.b = [0.0, 0.0, 0.0]
linear13: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 6-element Array{Float64,1} at index [7]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize!(::MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.Model{Float64}}}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Utilities/cachingoptimizer.jl:215
   [8] optimize! at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Bridges/bridge_optimizer.jl:264 [inlined]
   [9] linear13test(::MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64,F,S,LS,US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction,MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.Model{Float64}}}}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/contlinear.jl:1549
   [10] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [11] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [12] contlineartest(::MathOptInterface.Bridges.Constraint.SingleBridgeOptimizer{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64,F,S,LS,US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction,MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.Model{Float64}}}}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [13] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:76
   [14] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [15] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:66
   [16] include(::String) at ./client.jl:457
   [17] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [18] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [19] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [20] include(::Function, ::Module, ::String) at ./Base.jl:380
   [21] include(::Module, ::String) at ./Base.jl:368
   [22] exec_options(::Base.JLOptions) at ./client.jl:296
   [23] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 8.106231689453125e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 3.0994415283203125e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 4.0531158447265625e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.8848648071289062e-5
-----> LP OPT5 time: 1.9788742065429688e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0, 1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [-Inf, -Inf]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [1.0, 2.0]
qp.c_ub = [Inf, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [0.0, 0.0]
c = [1.0, 1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0), MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(1.0), MathOptInterface.GreaterThan{Float64}(2.0)]
-> check2
---> check4
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 0.0 -1.0 0.0; 1.0 1.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, -1000.0, -1000.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0]
-----> check2_1 time: 0.0010290145874023438
-----> check3 time: 0.0
-----> check4 time: 1.9073486328125e-6
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.0013580322265625e-5
-----> check8 time: 1.7881393432617188e-5
-----> check9 time: 0.0
     1  +0.00000000e+00  +3.00000000e+01  -2.80000000e+01  +2.00000000e+00  1.41280006e+03  1.00000000e+01  1.00000000e+03  0.00000000e+00  2.00000000e+00  0.00000000e+00  1.00000000e+00  1.00000000e+00
-----> check10 time: 3.600120544433594e-5
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> LP OPT1 time: 1.1920928955078125e-6
-----> LP OPT2 time: 7.867813110351562e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.5974044799804688e-5
-----> LP OPT5 time: 1.2159347534179688e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0, 1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [-Inf, -Inf]
qp.v_ub = [Inf, Inf]
x_k = [-998.0, 1000.0]
qp.c_lb = [1.0, 2.0]
qp.c_ub = [Inf, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [2.0, 2.0]
c = [1.0, 1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0), MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check2
---> check4
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 0.0 -1.0 0.0; 1.0 1.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, -1000.0, -1000.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0]
-----> check2_1 time: 0.0007009506225585938
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.152557373046875e-6
-----> check8 time: 1.2159347534179688e-5
-----> check9 time: 0.0
     2  +2.00000000e+00  +2.00000000e+00  +0.00000000e+00  +0.00000000e+00  1.41421356e+03  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 1.9073486328125e-6
-----> LP OPT1 time: 0.0
-----> LP OPT2 time: 2.86102294921875e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 1.811981201171875e-5
-----> LP OPT5 time: 1.5974044799804688e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0, 1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [-Inf, -Inf]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [-Inf, 1.0]
qp.c_ub = [2.0, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [0.0, 0.0]
c = [1.0, 1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(2.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(1.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 0.0 -1.0 0.0; 1.0 1.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, -1000.0, -1000.0, 0.0, 0.0, 0.0, 0.0, 2.0, 1.0]
-----> check2_1 time: 0.0009548664093017578
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 2.86102294921875e-6
-----> KT_residuals1 time: 1.1920928955078125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.5020370483398438e-5
-----> check9 time: 9.5367431640625e-7
     1  +0.00000000e+00  +1.00000000e+01  -9.00000000e+00  +1.00000000e+00  1.41350663e+03  1.00000000e+01  1.00000000e+03  0.00000000e+00  1.00000000e+00  0.00000000e+00  5.00000000e-01  1.00000000e+00
-----> check10 time: 2.384185791015625e-5
-----> check start
-----> check1 time: 1.9073486328125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 1.0013580322265625e-5
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.6927719116210938e-5
-----> LP OPT5 time: 1.2874603271484375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0, 1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [-Inf, -Inf]
qp.v_ub = [Inf, Inf]
x_k = [-999.0, 1000.0]
qp.c_lb = [-Inf, 1.0]
qp.c_ub = [2.0, Inf]
qp.A = 
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  1.0
qp.b = [1.0, 1.0]
c = [1.0, 1.0, 1000.0, 1000.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})]
mn = 10
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(5), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(6)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(5)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(6))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(5)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1.0)]
-> check2
---> check3
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(6)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0)]
-> check2
---> check4
A = [1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 0.0 -1.0 0.0; 1.0 1.0 0.0 1.0 0.0 -1.0]
b = [1000.0, 1000.0, -1000.0, -1000.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]
-----> check2_1 time: 0.0008509159088134766
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 5.9604644775390625e-6
-----> check8 time: 1.1920928955078125e-5
-----> check9 time: 0.0
     2  +1.00000000e+00  +1.00000000e+00  +0.00000000e+00  +0.00000000e+00  1.41421356e+03  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 8.106231689453125e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 2.1457672119140625e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 3.814697265625e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 2.1457672119140625e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [1.0, 0.0]
mult_x_U = [0.0, -1.0]
qp.v_lb = [0.0, -Inf]
qp.v_ub = [Inf, 0.0]
x_k = [0.0, 0.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [1.0, -1.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 4
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(0.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-1000.0)]
-> check1
---> check2
-> check1
---> check2
A = [1.0 0.0; 0.0 1.0; 1.0 0.0; 0.0 1.0]
b = [1000.0, 0.0, 0.0, -1000.0]
-----> check2_1 time: 0.0008230209350585938
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 1.9073486328125e-6
-----> check7 time: 1.1920928955078125e-6
-----> Jacobian time: 0.0
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.4066696166992188e-5
-----> check8 time: 1.8835067749023438e-5
-----> check9 time: 9.5367431640625e-7
     1  +0.00000000e+00  +0.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 2.1457672119140625e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [1.0, 0.0]
mult_x_U = [0.0, -1.0]
qp.v_lb = [100.0, -Inf]
qp.v_ub = [Inf, 0.0]
x_k = [100.0, 0.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [1.0, -1.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 4
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(0.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-1000.0)]
-> check1
---> check2
-> check1
---> check2
A = [1.0 0.0; 0.0 1.0; 1.0 0.0; 0.0 1.0]
b = [1000.0, 0.0, 0.0, -1000.0]
-----> check2_1 time: 0.00047397613525390625
-----> check3 time: 0.0
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 0.0
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.152557373046875e-6
-----> check8 time: 1.0967254638671875e-5
-----> check9 time: 0.0
     1  +1.00000000e+02  +1.00000000e+02  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 0.0
-----> LP OPT2 time: 2.1457672119140625e-6
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 0.0
-----> LP OPT5 time: 1.1920928955078125e-6
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = Float64[]
mult_x_L = [1.0, 0.0]
mult_x_U = [0.0, -1.0]
qp.v_lb = [100.0, -Inf]
qp.v_ub = [Inf, -100.0]
x_k = [100.0, -100.0]
qp.c_lb = Float64[]
qp.c_ub = Float64[]
qp.A = 0×0 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = Float64[]
c = [1.0, -1.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64})]
mn = 4
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(0.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-1000.0)]
-> check1
---> check2
-> check1
---> check2
A = [1.0 0.0; 0.0 1.0; 1.0 0.0; 0.0 1.0]
b = [1000.0, 0.0, 0.0, -1000.0]
-----> check2_1 time: 0.00046896934509277344
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.0967254638671875e-5
-----> check9 time: 0.0
     1  +2.00000000e+02  +2.00000000e+02  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 9.059906005859375e-6
-----> check2 time: 0.0
-----> Jacobian time: 4.0531158447265625e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 4.0531158447265625e-6
-----> LP OPT3 time: 2.86102294921875e-6
-----> LP OPT4 time: 2.3126602172851562e-5
-----> LP OPT5 time: 2.09808349609375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [1.0]
mult_x_L = [0.0, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [0.0]
c = [1.0, 1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.EqualTo{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.EqualTo{Float64}[MathOptInterface.EqualTo{Float64}(1.0)]
-> check2
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.4224700927734375
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 1.9073486328125e-6
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 3.0994415283203125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.5974044799804688e-5
-----> check8 time: 2.5033950805664062e-5
-----> check9 time: 9.5367431640625e-7
     1  +1.00000000e+00  +1.10000000e+01  -9.00000000e+00  +1.00000000e+00  1.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  1.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
-----> check10 time: 4.1961669921875e-5
-----> check start
-----> check1 time: 6.9141387939453125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 1.9788742065429688e-5
-----> LP OPT3 time: 4.0531158447265625e-6
-----> LP OPT4 time: 1.5020370483398438e-5
-----> LP OPT5 time: 2.09808349609375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [2.0]
mult_x_L = [0.0, 1.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 1.0]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [1.0]
c = [2.0, 3.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(-1.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.EqualTo{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.EqualTo{Float64}[MathOptInterface.EqualTo{Float64}(0.0)]
-> check2
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, 0.0, -1.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0009829998016357422
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 8.106231689453125e-6
-----> check8 time: 1.4066696166992188e-5
-----> check9 time: 9.5367431640625e-7
     2  +3.00000000e+00  +3.00000000e+00  -1.00000000e+00  -1.00000000e+00  1.41421356e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  5.00000000e-01  1.00000000e+00
-----> check10 time: 2.7894973754882812e-5
-----> check start
-----> check1 time: 5.0067901611328125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 1.1920928955078125e-6
-----> LP OPT2 time: 7.867813110351562e-6
-----> LP OPT3 time: 2.1457672119140625e-6
-----> LP OPT4 time: 1.0967254638671875e-5
-----> LP OPT5 time: 1.3113021850585938e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [2.717570463519]
mult_x_L = [0.12971814592400044, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.28242953648100017, 0.7175704635189999]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [1.0]
c = [2.8472886094430003, 2.717570463519, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-0.28242953648100017), MathOptInterface.GreaterThan{Float64}(-0.7175704635189999), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.EqualTo{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.EqualTo{Float64}[MathOptInterface.EqualTo{Float64}(0.0)]
-> check2
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, -0.28242953648100017, -0.7175704635189999, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0006189346313476562
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 9.5367431640625e-7
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 5.9604644775390625e-6
-----> check8 time: 1.3113021850585938e-5
-----> check9 time: 0.0
     3  +2.87710335e+00  +2.87710335e+00  -3.66362358e-02  -3.66362358e-02  3.99415681e-01  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  3.24295365e-02  1.00000000e+00
-----> check10 time: 2.5987625122070312e-5
-----> check start
-----> check1 time: 1.9073486328125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 0.0
-----> LP OPT2 time: 7.152557373046875e-6
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 9.059906005859375e-6
-----> LP OPT5 time: 1.1920928955078125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [2.7328324820999166]
mult_x_L = [0.0, 0.022890023866778186]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.24427749403330554, 0.7557225059666945]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [1.0]
c = [2.7328324820999166, 2.7557225059666948, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-0.24427749403330554), MathOptInterface.GreaterThan{Float64}(-0.7557225059666945), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.EqualTo{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.EqualTo{Float64}[MathOptInterface.EqualTo{Float64}(0.0)]
-> check2
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, -0.24427749403330554, -0.7557225059666945, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0007009506225585938
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.1920928955078125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.152557373046875e-6
-----> check8 time: 1.3113021850585938e-5
-----> check9 time: 0.0
     4  +2.87506549e+00  +2.87506549e+00  -1.72985062e-02  -1.72985062e-02  1.06875302e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.69114038e-02  1.00000000e+00
-----> check10 time: 3.314018249511719e-5
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 7.152557373046875e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.0967254638671875e-5
-----> LP OPT5 time: 1.0967254638671875e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [2.749126587467033]
mult_x_L = [0.0034936501318671986, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.2508734125329668, 0.7491265874670333]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [1.0]
c = [2.7526202375989004, 2.749126587467033, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-0.2508734125329668), MathOptInterface.GreaterThan{Float64}(-0.7491265874670333), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.EqualTo{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.EqualTo{Float64}[MathOptInterface.EqualTo{Float64}(0.0)]
-> check2
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, -0.2508734125329668, -0.7491265874670333, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0006010532379150391
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.152557373046875e-6
-----> check8 time: 1.1920928955078125e-5
-----> check9 time: 9.5367431640625e-7
     5  +2.87500153e+00  +2.87500153e+00  -8.76463931e-04  -8.76463931e-04  3.54788582e-01  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  8.73412533e-04  1.00000000e+00
-----> check10 time: 3.504753112792969e-5
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 5.9604644775390625e-6
-----> LP OPT3 time: 2.1457672119140625e-6
-----> LP OPT4 time: 1.0013580322265625e-5
-----> LP OPT5 time: 1.1920928955078125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [2.7494783808268384]
mult_x_L = [0.0, 0.0006954922308826106]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.24982612694227935, 0.7501738730577208]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [1.0]
c = [2.7494783808268384, 2.750173873057721, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-0.24982612694227935), MathOptInterface.GreaterThan{Float64}(-0.7501738730577208), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.EqualTo{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.EqualTo{Float64}[MathOptInterface.EqualTo{Float64}(0.0)]
-> check2
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, -0.24982612694227935, -0.7501738730577208, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0006020069122314453
-----> check3 time: 0.0
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 5.9604644775390625e-6
-----> check8 time: 1.3113021850585938e-5
-----> check9 time: 0.0
     6  +2.87500006e+00  +2.87500006e+00  -5.21740101e-04  -5.21740101e-04  1.06090607e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  5.21377487e-04  1.00000000e+00
-----> check10 time: 4.100799560546875e-5
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 1.1920928955078125e-6
-----> LP OPT2 time: 6.9141387939453125e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.0013580322265625e-5
-----> LP OPT5 time: 1.1205673217773438e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [2.7499715349562077]
mult_x_L = [0.00011386017517001079, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.2500284650437926, 0.7499715349562075]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [1.0]
c = [2.7500853951313777, 2.7499715349562077, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-0.2500284650437926), MathOptInterface.GreaterThan{Float64}(-0.7499715349562075), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.EqualTo{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.EqualTo{Float64}[MathOptInterface.EqualTo{Float64}(0.0)]
-> check2
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, -0.2500284650437926, -0.7499715349562075, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0005939006805419922
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 9.5367431640625e-7
-----> KT_residuals3 time: 5.9604644775390625e-6
-----> check8 time: 1.0967254638671875e-5
-----> check9 time: 0.0
     7  +2.87500000e+00  +2.87500000e+00  -2.84682848e-05  -2.84682848e-05  3.53593646e-01  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  2.84650438e-05  1.00000000e+00
-----> check10 time: 4.38690185546875e-5
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 0.0
-----> Jacobian time: 0.0
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 7.152557373046875e-6
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 9.059906005859375e-6
-----> LP OPT5 time: 1.0967254638671875e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [2.749988628858945]
mult_x_L = [0.0, 1.5161521406792389e-5]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.24999620961964825, 0.7500037903803519]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [1.0000000000000002]
c = [2.749988628858945, 2.750003790380352, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-0.24999620961964825), MathOptInterface.GreaterThan{Float64}(-0.7500037903803519), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.EqualTo{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.EqualTo{Float64}[MathOptInterface.EqualTo{Float64}(0.0)]
-> check2
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, -0.24999620961964825, -0.7500037903803519, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0006558895111083984
-----> check3 time: 1.1920928955078125e-6
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.152557373046875e-6
-----> check8 time: 1.3113021850585938e-5
-----> check9 time: 9.5367431640625e-7
     8  +2.87500000e+00  +2.87500000e+00  -1.13711985e-05  -1.13711985e-05  1.06066553e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  2.22044605e-16  0.00000000e+00  1.13710261e-05  1.00000000e+00
-----> check10 time: 5.1975250244140625e-5
-----> check start
-----> check1 time: 2.1457672119140625e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 6.9141387939453125e-6
-----> LP OPT3 time: 2.1457672119140625e-6
-----> LP OPT4 time: 1.0013580322265625e-5
-----> LP OPT5 time: 1.0967254638671875e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [2.749999688792258]
mult_x_L = [1.244830968527566e-6, 0.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.25000031120774213, 0.749999688792258]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [1.0]
c = [2.7500009336232267, 2.749999688792258, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-0.25000031120774213), MathOptInterface.GreaterThan{Float64}(-0.749999688792258), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.EqualTo{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.EqualTo{Float64}[MathOptInterface.EqualTo{Float64}(0.0)]
-> check2
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, -0.25000031120774213, -0.749999688792258, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0006051063537597656
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 1.1920928955078125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 5.9604644775390625e-6
-----> check8 time: 1.1920928955078125e-5
-----> check9 time: 0.0
     9  +2.87500000e+00  +2.87500000e+00  -3.11208130e-07  -3.11208130e-07  3.53553831e-01  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  3.11207742e-07  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 1.9073486328125e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.0967254638671875e-5
-----> LP OPT5 time: 1.3828277587890625e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-2.0]
mult_x_L = [0.0, 1.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [0.0, 0.0]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [0.0]
c = [-2.0, -1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.EqualTo{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.EqualTo{Float64}[MathOptInterface.EqualTo{Float64}(1.0)]
-> check2
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, 0.0, 0.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.00061798095703125
-----> check3 time: 0.0
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.2874603271484375e-5
-----> check9 time: 9.5367431640625e-7
     1  -1.00000000e+00  +9.00000000e+00  -1.20000000e+01  -2.00000000e+00  1.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  1.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
-----> check10 time: 2.2172927856445312e-5
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 7.152557373046875e-6
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 1.0013580322265625e-5
-----> LP OPT5 time: 1.1205673217773438e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-2.0]
mult_x_L = [0.0, 1.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [0.0, 0.0]
qp.v_ub = [Inf, Inf]
x_k = [1.0, 0.0]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  1.0
qp.b = [1.0]
c = [-2.0, -1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64})]
mn = 7
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(2)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0), MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(4)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(4))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.EqualTo{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(4)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.EqualTo{Float64}[MathOptInterface.EqualTo{Float64}(0.0)]
-> check2
A = [1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0; 1.0 1.0 1.0 -1.0]
b = [1000.0, 1000.0, -1.0, 0.0, 0.0, 0.0, 0.0]
-----> check2_1 time: 0.0006589889526367188
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 1.1920928955078125e-6
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.3113021850585938e-5
-----> check9 time: 0.0
     2  -3.00000000e+00  -3.00000000e+00  +0.00000000e+00  +0.00000000e+00  0.00000000e+00  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 9.059906005859375e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 2.86102294921875e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 6.9141387939453125e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 2.3126602172851562e-5
-----> LP OPT5 time: 1.5974044799804688e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [0.0]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 1×1 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = [0.0]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(2.0)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 0.0 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, 2.0]
-----> check2_1 time: 0.000926971435546875
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.0013580322265625e-5
-----> check8 time: 1.5974044799804688e-5
-----> check9 time: 0.0
     1  +0.00000000e+00  +0.00000000e+00  -1.00000000e+03  -1.00000000e+03  1.00000000e+03  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  1.00000000e+00  0.00000000e+00  1.00000000e+00
-----> check10 time: 4.982948303222656e-5
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 1.1920928955078125e-6
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 8.106231689453125e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.0013580322265625e-5
-----> LP OPT5 time: 1.2874603271484375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.3816734140444743]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [1.3100205086376222]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 
  [1, 1]  =  2.62004
qp.b = [1.7161537330511745]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.6200410172752444, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.28384626694882553)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.6200410172752444 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, 0.28384626694882553]
-----> check2_1 time: 0.0005958080291748047
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 1.1920928955078125e-6
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 1.1920928955078125e-6
-----> KT_residuals3 time: 5.9604644775390625e-6
-----> check8 time: 1.1920928955078125e-5
-----> check9 time: 0.0
     2  -1.31002051e+00  -1.31002051e+00  -1.08336574e-01  -1.08336574e-01  1.08336574e-01  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  7.84096825e-02  1.00000000e+00
-----> check10 time: 2.193450927734375e-5
-----> check start
-----> check1 time: 2.86102294921875e-6
-----> check2 time: 0.0
-----> Jacobian time: 0.0
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 6.9141387939453125e-6
-----> LP OPT3 time: 1.1920928955078125e-6
-----> LP OPT4 time: 1.0013580322265625e-5
-----> LP OPT5 time: 1.0013580322265625e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.3552338746966554]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [1.4075234250308044]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 
  [1, 1]  =  2.81505
qp.b = [1.9811221920104465]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.815046850061609, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.01887780798955352)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.815046850061609 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, 0.01887780798955352]
-----> check2_1 time: 0.0005841255187988281
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 0.0
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.0967254638671875e-5
-----> check9 time: 0.0
     3  -1.40752343e+00  -1.40752343e+00  -6.70603688e-03  -6.70603688e-03  6.70603688e-03  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  4.94825063e-03  1.00000000e+00
-----> check10 time: 2.002716064453125e-5
-----> check start
-----> check1 time: 1.9073486328125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 5.9604644775390625e-6
-----> LP OPT3 time: 2.1457672119140625e-6
-----> LP OPT4 time: 1.0013580322265625e-5
-----> LP OPT5 time: 1.0013580322265625e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.3535494157540412]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [1.4142294619087765]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 
  [1, 1]  =  2.82846
qp.b = [2.0000449709307877]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.828458923817553, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(-4.49709307877022e-5)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.828458923817553 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, -4.49709307877022e-5]
-----> check2_1 time: 0.0005810260772705078
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 9.5367431640625e-7
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.198883056640625e-6
-----> check8 time: 1.2159347534179688e-5
-----> check9 time: 0.0
     4  -1.41422946e+00  -1.41377975e+00  -4.33809862e-04  +1.58994463e-05  1.58994463e-05  1.00000000e+01  1.00000000e+03  0.00000000e+00  4.49709308e-05  0.00000000e+00  1.17464838e-05  1.00000000e+00
-----> check10 time: 2.002716064453125e-5
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 1.1920928955078125e-6
-----> LP OPT2 time: 6.9141387939453125e-6
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 9.059906005859375e-6
-----> LP OPT5 time: 1.1205673217773438e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.35355339057093815]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [1.4142135624624375]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 
  [1, 1]  =  2.82843
qp.b = [2.0000000002526983]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.828427124924875, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(-2.5269830672414173e-10)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.828427124924875 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, -2.5269830672414173e-10]
-----> check2_1 time: 0.0005810260772705078
-----> check3 time: 0.0
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 1.1920928955078125e-6
-----> KT_residuals2 time: 9.5367431640625e-7
-----> KT_residuals3 time: 6.9141387939453125e-6
-----> check8 time: 1.2874603271484375e-5
-----> check9 time: 0.0
     5  -1.41421356e+00  -1.41421356e+00  -2.43762521e-09  +8.93578544e-11  8.93578544e-11  1.00000000e+01  1.00000000e+03  0.00000000e+00  2.52698307e-10  0.00000000e+00  6.60057769e-11  1.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 9.059906005859375e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 2.86102294921875e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.193450927734375e-5
-----> LP OPT5 time: 2.002716064453125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-1.0]
mult_x_L = [0.0, 2.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [-Inf, 1.0]
qp.v_ub = [Inf, 1.0]
x_k = [0.0, 1.0]
qp.c_lb = [-Inf]
qp.c_ub = [3.0]
qp.A = 
  [1, 1]  =  1.0
  [1, 2]  =  2.0
qp.b = [1.0]
qcp4: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 3-element Array{Float64,1} at index [4]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize!(::MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.Model{Float64}}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Utilities/cachingoptimizer.jl:215
   [8] _qcp4test(::MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.Model{Float64}}, ::MathOptInterface.Test.TestConfig{Float64}, ::Bool) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/contquadratic.jl:498
   [9] qcp4test(::MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.Model{Float64}}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/contquadratic.jl:525
   [10] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [11] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [12] qcptest(::MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.Model{Float64}}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [13] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:97
   [14] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [15] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:95
   [16] include(::String) at ./client.jl:457
   [17] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [18] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [19] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [20] include(::Function, ::Module, ::String) at ./Base.jl:380
   [21] include(::Module, ::String) at ./Base.jl:368
   [22] exec_options(::Base.JLOptions) at ./client.jl:296
   [23] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 1.0967254638671875e-5
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 3.814697265625e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 4.0531158447265625e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.5033950805664062e-5
-----> LP OPT5 time: 2.09808349609375e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [1.0]
mult_x_L = [0.0, 2.0]
mult_x_U = [0.0, 0.0]
qp.v_lb = [-Inf, 1.0]
qp.v_ub = [Inf, 1.0]
x_k = [0.0, 1.0]
qp.c_lb = [-3.0]
qp.c_ub = [Inf]
qp.A = 
  [1, 1]  =  -1.0
  [1, 2]  =  -2.0
qp.b = [-1.0]
qcp5: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 3-element Array{Float64,1} at index [4]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] optimize!(::MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.Model{Float64}}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Utilities/cachingoptimizer.jl:215
   [8] _qcp4test(::MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.Model{Float64}}, ::MathOptInterface.Test.TestConfig{Float64}, ::Bool) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/contquadratic.jl:498
   [9] qcp5test(::MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.Model{Float64}}, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/contquadratic.jl:526
   [10] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [11] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [12] qcptest(::MathOptInterface.Utilities.CachingOptimizer{ActiveSetMethods.Optimizer,MathOptInterface.Utilities.Model{Float64}}, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [13] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:97
   [14] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [15] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:95
   [16] include(::String) at ./client.jl:457
   [17] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [18] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [19] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [20] include(::Function, ::Module, ::String) at ./Base.jl:380
   [21] include(::Module, ::String) at ./Base.jl:368
   [22] exec_options(::Base.JLOptions) at ./client.jl:296
   [23] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 9.059906005859375e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 2.86102294921875e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 7.152557373046875e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 2.09808349609375e-5
-----> LP OPT5 time: 1.5020370483398438e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [0.0]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 1×1 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries
qp.b = [0.0]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(2.0)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 0.0 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, 2.0]
-----> check2_1 time: 0.0009760856628417969
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 1.1920928955078125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 1.1920928955078125e-5
-----> check8 time: 1.8835067749023438e-5
-----> check9 time: 0.0
     1  -0.00000000e+00  +0.00000000e+00  -1.00000000e+03  -1.00000000e+03  1.00000000e+03  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  1.00000000e+00  0.00000000e+00  2.00000000e+00
-----> check10 time: 4.696846008300781e-5
-----> check start
-----> check1 time: 4.0531158447265625e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 1.1920928955078125e-6
-----> LP OPT2 time: 1.0013580322265625e-5
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.2159347534179688e-5
-----> LP OPT5 time: 1.1920928955078125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.3816734140444743]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [1.3100205086376222]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 
  [1, 1]  =  2.62004
qp.b = [1.7161537330511745]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.6200410172752444, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.28384626694882553)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.6200410172752444 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, 0.28384626694882553]
-----> check2_1 time: 0.0005359649658203125
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> KT_residuals1 time: 1.1920928955078125e-6
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 5.9604644775390625e-6
-----> check8 time: 1.0967254638671875e-5
-----> check9 time: 0.0
     2  -1.31002051e+00  -1.31002051e+00  -1.08336574e-01  -1.08336574e-01  1.08336574e-01  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  7.84096825e-02  2.00000000e+00
-----> check10 time: 1.9073486328125e-5
-----> check start
-----> check1 time: 2.1457672119140625e-6
-----> check2 time: 0.0
-----> Jacobian time: 1.9073486328125e-6
-----> LP OPT1 time: 0.0
-----> LP OPT2 time: 7.295608520507812e-5
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 1.2159347534179688e-5
-----> LP OPT5 time: 1.1920928955078125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.3552338746966554]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [1.4075234250308044]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 
  [1, 1]  =  2.81505
qp.b = [1.9811221920104465]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.815046850061609, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(0.01887780798955352)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.815046850061609 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, 0.01887780798955352]
-----> check2_1 time: 0.0008258819580078125
-----> check3 time: 0.0
-----> check4 time: 0.0
-----> check5 time: 0.0
-----> check6 time: 9.5367431640625e-7
-----> check7 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 7.867813110351562e-6
-----> check8 time: 1.3828277587890625e-5
-----> check9 time: 1.1920928955078125e-6
     3  -1.40752343e+00  -1.40752343e+00  -6.70603688e-03  -6.70603688e-03  6.70603688e-03  1.00000000e+01  1.00000000e+03  0.00000000e+00  0.00000000e+00  0.00000000e+00  4.94825063e-03  2.00000000e+00
-----> check10 time: 1.9788742065429688e-5
-----> check start
-----> check1 time: 1.9073486328125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 0.0
-----> LP OPT2 time: 8.106231689453125e-6
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 3.910064697265625e-5
-----> LP OPT5 time: 2.9087066650390625e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.3535494157540412]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [1.4142294619087765]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 
  [1, 1]  =  2.82846
qp.b = [2.0000449709307877]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.828458923817553, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(-4.49709307877022e-5)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.828458923817553 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, -4.49709307877022e-5]
-----> check2_1 time: 0.000621795654296875
-----> check3 time: 9.5367431640625e-7
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 2.1457672119140625e-6
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 6.198883056640625e-6
-----> check8 time: 1.2159347534179688e-5
-----> check9 time: 0.0
     4  -1.41422946e+00  -1.41377975e+00  -4.33809862e-04  +1.58994463e-05  1.58994463e-05  1.00000000e+01  1.00000000e+03  0.00000000e+00  4.49709308e-05  0.00000000e+00  1.17464838e-05  2.00000000e+00
-----> check10 time: 1.9073486328125e-5
-----> check start
-----> check1 time: 3.0994415283203125e-6
-----> check2 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 6.9141387939453125e-6
-----> LP OPT3 time: 9.5367431640625e-7
-----> LP OPT4 time: 8.821487426757812e-6
-----> LP OPT5 time: 1.0013580322265625e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [-0.35355339057093815]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [1.4142135624624375]
qp.c_lb = [-Inf]
qp.c_ub = [2.0]
qp.A = 
  [1, 1]  =  2.82843
qp.b = [2.0000000002526983]
c = [-1.0, 1000.0, 1000.0]
cons = Tuple{DataType,DataType}[(MathOptInterface.SingleVariable, MathOptInterface.LessThan{Float64}), (MathOptInterface.SingleVariable, MathOptInterface.GreaterThan{Float64}), (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64})]
mn = 5
F = MathOptInterface.SingleVariable
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1))]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(1000.0)]
-> check1
---> check1
F = MathOptInterface.SingleVariable
S = MathOptInterface.GreaterThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(1), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(2), MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}}(3)]
f = MathOptInterface.SingleVariable[MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(1)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(2)), MathOptInterface.SingleVariable(MathOptInterface.VariableIndex(3))]
s = MathOptInterface.GreaterThan{Float64}[MathOptInterface.GreaterThan{Float64}(-1000.0), MathOptInterface.GreaterThan{Float64}(0.0), MathOptInterface.GreaterThan{Float64}(0.0)]
-> check1
---> check2
-> check1
---> check2
-> check1
---> check2
F = MathOptInterface.ScalarAffineFunction{Float64}
S = MathOptInterface.LessThan{Float64}
ci = MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}[MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}}(1)]
f = MathOptInterface.ScalarAffineFunction{Float64}[MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(-1.0, MathOptInterface.VariableIndex(3)), MathOptInterface.ScalarAffineTerm{Float64}(1.0, MathOptInterface.VariableIndex(2)), MathOptInterface.ScalarAffineTerm{Float64}(2.828427124924875, MathOptInterface.VariableIndex(1))], 0.0)]
s = MathOptInterface.LessThan{Float64}[MathOptInterface.LessThan{Float64}(-2.5269830672414173e-10)]
-> check2
---> check3
A = [1.0 0.0 0.0; 1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0; 2.828427124924875 1.0 -1.0]
b = [1000.0, -1000.0, 0.0, 0.0, -2.5269830672414173e-10]
-----> check2_1 time: 0.0005960464477539062
-----> check3 time: 0.0
-----> check4 time: 9.5367431640625e-7
-----> check5 time: 0.0
-----> check6 time: 0.0
-----> check7 time: 0.0
-----> Jacobian time: 9.5367431640625e-7
-----> KT_residuals1 time: 9.5367431640625e-7
-----> KT_residuals2 time: 0.0
-----> KT_residuals3 time: 5.9604644775390625e-6
-----> check8 time: 1.0967254638671875e-5
-----> check9 time: 0.0
     5  -1.41421356e+00  -1.41421356e+00  -2.43762521e-09  +8.93578544e-11  8.93578544e-11  1.00000000e+01  1.00000000e+03  0.00000000e+00  2.52698307e-10  0.00000000e+00  6.60057769e-11  2.00000000e+00
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 9.059906005859375e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 2.86102294921875e-6
-----> LP OPT1 time: 1.9073486328125e-6
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.09808349609375e-5
-----> LP OPT5 time: 2.002716064453125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [1.5]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  3.0
qp.b = [2.25]
feasibility_sense_with_objective_and_hessian: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 2-element Array{Float64,1} at index [3]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] feasibility_sense_test_template(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}, ::Bool, ::MathOptInterface.Test.FeasibilitySenseEvaluator) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/nlp.jl:270
   [8] feasibility_sense_with_objective_and_hessian_test(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/nlp.jl:285
   [9] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [10] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [11] nlptest(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [12] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:105
   [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [14] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:104
   [15] include(::String) at ./client.jl:457
   [16] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [17] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [18] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [19] include(::Function, ::Module, ::String) at ./Base.jl:380
   [20] include(::Module, ::String) at ./Base.jl:368
   [21] exec_options(::Base.JLOptions) at ./client.jl:296
   [22] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 7.867813110351562e-6
-----> check2 time: 0.0
-----> Jacobian time: 3.0994415283203125e-6
-----> LP OPT1 time: 2.1457672119140625e-6
-----> LP OPT2 time: 4.0531158447265625e-6
-----> LP OPT3 time: 1.9073486328125e-6
-----> LP OPT4 time: 2.2172927856445312e-5
-----> LP OPT5 time: 1.9073486328125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [1.5]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  3.0
qp.b = [2.25]
feasibility_sense_with_no_objective_and_no_hessian: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 2-element Array{Float64,1} at index [3]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] feasibility_sense_test_template(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}, ::Bool, ::MathOptInterface.Test.FeasibilitySenseEvaluator) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/nlp.jl:270
   [8] feasibility_sense_with_no_objective_and_no_hessian_test(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/nlp.jl:300
   [9] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [10] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [11] nlptest(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [12] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:105
   [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [14] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:104
   [15] include(::String) at ./client.jl:457
   [16] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [17] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [18] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [19] include(::Function, ::Module, ::String) at ./Base.jl:380
   [20] include(::Module, ::String) at ./Base.jl:368
   [21] exec_options(::Base.JLOptions) at ./client.jl:296
   [22] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 8.106231689453125e-6
-----> check2 time: 0.0
-----> Jacobian time: 3.0994415283203125e-6
-----> LP OPT1 time: 2.1457672119140625e-6
-----> LP OPT2 time: 2.86102294921875e-6
-----> LP OPT3 time: 2.86102294921875e-6
-----> LP OPT4 time: 2.1219253540039062e-5
-----> LP OPT5 time: 1.7881393432617188e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [1.5]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  3.0
qp.b = [2.25]
feasibility_sense_with_objective_and_no_hessian: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 2-element Array{Float64,1} at index [3]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] feasibility_sense_test_template(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}, ::Bool, ::MathOptInterface.Test.FeasibilitySenseEvaluator) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/nlp.jl:270
   [8] feasibility_sense_with_objective_and_no_hessian_test(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/nlp.jl:290
   [9] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [10] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [11] nlptest(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [12] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:105
   [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [14] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:104
   [15] include(::String) at ./client.jl:457
   [16] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [17] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [18] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [19] include(::Function, ::Module, ::String) at ./Base.jl:380
   [20] include(::Module, ::String) at ./Base.jl:368
   [21] exec_options(::Base.JLOptions) at ./client.jl:296
   [22] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 8.106231689453125e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 2.86102294921875e-6
-----> LP OPT1 time: 9.5367431640625e-7
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 3.0994415283203125e-6
-----> LP OPT4 time: 2.288818359375e-5
-----> LP OPT5 time: 2.002716064453125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [1.5]
qp.c_lb = [1.0]
qp.c_ub = [1.0]
qp.A = 
  [1, 1]  =  3.0
qp.b = [2.25]
feasibility_sense_with_no_objective_and_with_hessian: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 2-element Array{Float64,1} at index [3]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] feasibility_sense_test_template(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}, ::Bool, ::MathOptInterface.Test.FeasibilitySenseEvaluator) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/nlp.jl:270
   [8] feasibility_sense_with_no_objective_and_with_hessian_test(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/nlp.jl:295
   [9] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [10] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [11] nlptest(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [12] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:105
   [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [14] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:104
   [15] include(::String) at ./client.jl:457
   [16] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [17] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [18] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [19] include(::Function, ::Module, ::String) at ./Base.jl:380
   [20] include(::Module, ::String) at ./Base.jl:368
   [21] exec_options(::Base.JLOptions) at ./client.jl:296
   [22] _start() at ./client.jl:506
  
  iter           f(x_k)           ϕ(x_k)           D(ϕ,p)            ∇f^Tp             |p|         μ_merit            μ_lp            m(p)          inf_pr          inf_du           compl        Sparsity
-----> check start
-----> check1 time: 7.867813110351562e-6
-----> check2 time: 9.5367431640625e-7
-----> Jacobian time: 3.0994415283203125e-6
-----> LP OPT1 time: 2.1457672119140625e-6
-----> LP OPT2 time: 3.0994415283203125e-6
-----> LP OPT3 time: 2.86102294921875e-6
-----> LP OPT4 time: 2.5033950805664062e-5
-----> LP OPT5 time: 2.002716064453125e-5
-----> TerminationStatus: OPTIMAL
-----> PrimalStatus: FEASIBLE_POINT
-----> DualStatus: FEASIBLE_POINT
lambda = [0.0]
mult_x_L = [0.0]
mult_x_U = [0.0]
qp.v_lb = [-Inf]
qp.v_ub = [Inf]
x_k = [1.5]
qp.c_lb = [1.0]
qp.c_ub = [2.0]
qp.A = 
  [1, 1]  =  3.0
qp.b = [2.25]
nlp_objective_and_moi_objective: Error During Test at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:47
  Got exception outside of a @test
  BoundsError: attempt to access 2-element Array{Float64,1} at index [3]
  Stacktrace:
   [1] setindex! at ./array.jl:847 [inlined]
   [2] sub_optimize!(::GLPK.Optimizer, ::ActiveSetMethods.QpData{Float64,Array{Float64,1},SparseArrays.SparseMatrixCSC{Float64,Int64}}, ::Float64, ::Array{Float64,1}, ::Float64, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/subproblem.jl:247
   [3] sub_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}, ::Float64) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:289
   [4] active_set_optimize!(::ActiveSetMethods.SlpLS{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/algorithms/slp_line_search.jl:137
   [5] optimize!(::ActiveSetMethods.Model{Float64,Array{Float64,1},Array{Tuple{Int64,Int64},1}}) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/model.jl:71
   [6] optimize!(::ActiveSetMethods.Optimizer) at /home/projects/projects/nonlinear_optimization/ActiveSetMethods/src/MOI_wrapper.jl:1152
   [7] nlp_objective_and_moi_objective_test(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/nlp.jl:335
   [8] macro expansion at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48 [inlined]
   [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]
   [10] nlptest(::ActiveSetMethods.Optimizer, ::MathOptInterface.Test.TestConfig{Float64}, ::Array{String,1}) at /home/projects/.julia/packages/MathOptInterface/ZJFKw/src/Test/config.jl:48
   [11] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:105
   [12] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [13] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/MOI_wrapper.jl:104
   [14] include(::String) at ./client.jl:457
   [15] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [16] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115
   [17] top-level scope at /home/projects/projects/nonlinear_optimization/ActiveSetMethodss/test/runtests1.jl:14
   [18] include(::Function, ::Module, ::String) at ./Base.jl:380
   [19] include(::Module, ::String) at ./Base.jl:368
   [20] exec_options(::Base.JLOptions) at ./client.jl:296
   [21] _start() at ./client.jl:506
  
Test Summary:                                            | Pass  Error  Total
MathOptInterface                                         |  507     19    526
  SolverName                                             |    1             1
  supports_default_copy_to                               |    2             2
  Unit                                                   |   87      9     96
    solve_qcp_edge_cases                                 |   14            14
    solve_farkas_interval_lower                          |           1      1
    add_variable                                         |    3             3
    solve_duplicate_terms_vector_affine                  |    6             6
    solve_single_variable_dual_max                       |              No tests
    solve_single_variable_dual_min                       |              No tests
    solver_name                                          |    1             1
    solve_time                                           |    6             6
    solve_duplicate_terms_obj                            |    8             8
    raw_status_string                                    |    6             6
    add_variables                                        |    3             3
    feasibility_sense                                    |    3             3
    solve_farkas_lessthan                                |           1      1
    max_sense                                            |    3             3
    solve_farkas_interval_upper                          |           1      1
    silent                                               |    4             4
    solve_farkas_greaterthan                             |           1      1
    min_sense                                            |    3             3
    solve_twice                                          |              No tests
    solve_farkas_variable_lessthan_max                   |           1      1
    solve_duplicate_terms_scalar_affine                  |    6             6
    solve_farkas_variable_lessthan                       |           1      1
    time_limit_sec                                       |    4             4
    solve_farkas_equalto_upper                           |           1      1
    solve_qp_edge_cases                                  |   17      1     18
      Basic model                                        |    5             5
      Duplicate linear terms                             |    5             5
      Duplicate diagonal terms                           |           1      1
      Duplicate off-diagonal terms                       |    5             5
    solve_farkas_equalto_lower                           |           1      1
  MOI Linear tests                                       |  284      3    287
    linear14                                             |   29            29
    linear6                                              |   34            34
    linear4                                              |   24            24
    linear3                                              |   28            28
    linear9                                              |   15            15
    linear1                                              |   22      1     23
    linear2                                              |   13      1     14
    partial_start                                        |    6             6
    linear10b                                            |   13            13
    linear10                                             |   26            26
    linear5                                              |   28            28
    linear13                                             |    6      1      7
    linear11                                             |   16            16
  MOI QP tests                                           |   18            18
  MOI QCQP tests                                         |   50      2     52
    qcp3                                                 |   14            14
    qcp4                                                 |   11      1     12
    qcp5                                                 |   11      1     12
    qcp2                                                 |   14            14
  MOI NLP tests                                          |   20      5     25
    feasibility_sense_with_objective_and_hessian         |    4      1      5
    feasibility_sense_with_no_objective_and_no_hessian   |    4      1      5
    feasibility_sense_with_objective_and_no_hessian      |    4      1      5
    feasibility_sense_with_no_objective_and_with_hessian |    4      1      5
    nlp_objective_and_moi_objective                      |    4      1      5
  Testing getters                                        |   37            37
  Bounds set twice                                       |    8             8
